<!DOCTYPE html>
<html lang="ru">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="../../bootstrap.min.css">
    <title>Document</title>
</head>

<body>
    <!-- Навигация -->
    <nav class="navbar navbar-expand-lg bg-body-tertiary">
        <div class="container-fluid">
            <a class="navbar-brand" href="#">Navbar</a>
            <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarNavDropdown"
                aria-controls="navbarNavDropdown" aria-expanded="false" aria-label="Toggle navigation">
                <span class="navbar-toggler-icon"></span>
            </button>
            <div class="collapse navbar-collapse" id="navbarNavDropdown">
                <ul class="navbar-nav">
                    <li class="nav-item">
                        <a class="nav-link active" aria-current="page" href="../../index.html">Главная</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link" href="#">Q&A</a>
                    </li>
                    <li class="nav-item dropdown">
                        <a class="nav-link dropdown-toggle" href="#" role="button" data-bs-toggle="dropdown"
                            aria-expanded="false">
                            Языки
                        </a>
                        <ul class="dropdown-menu">
                            <li><a class="dropdown-item" href="../pagesPython/mainPage.html">Python</a></li>
                            <li><a class="dropdown-item" href="../pagesJavaScript/mianPage.html">JavaScript</a></li>
                            <li><a class="dropdown-item" href="../pagesCSharp/mainPage.html">C#</a></li>
                            <li><a class="dropdown-item" href="../pagesPHP/mainPage.html">PHP</a></li>
                            <li><a class="dropdown-item" href="../pagesJava/mainPage.html">Java</a></li>
                        </ul>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link" href="#">Войти</a>
                    </li>
                </ul>
            </div>
        </div>
    </nav>
    <!--  -->
    <div class="container">
        <div class="row">
            <div class="col-3 m-2">
                <div class="accordion accordion-flush" id="accordionFlushExample">
                    <div class="card" style="width: 18rem;">
                        <div class="card-body">
                          <h5 class="card-title">Глава 1. Введение в Python</h5>
                          <p class="card-text">Язык программирования Python. Установка Python и первая программа на Windows</p>
                        </div>
                      </div>
                    <div class="card" style="width: 18rem;">
                        <div class="card-body">
                            <h5 class="card-title">Глава 2. Основы Python</h5>
                            <div class="accordion-item">
                                <h6 class="accordion-header">
                                    <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse"
                                        data-bs-target="#flush-collapse1" aria-expanded="false"
                                        aria-controls="flush-collapse1">
                                        Темы раздела
                                    </button>
                                </h6>
                                <div id="flush-collapse1" class="accordion-collapse collapse"
                                    data-bs-parent="#accordionFlushExample">
                                    <div class="accordion-body">
                                        <ul class="list-group">
                                            <li class="list-group-item"><a class="link-offset-2 link-underline link-underline-opacity-0" href="#them1">Введение в написание программ</a></li>
                                            <li class="list-group-item"><a class="link-offset-2 link-underline link-underline-opacity-0" href="#them2">Переменные и типы данных</a></li>
                                            <li class="list-group-item"><a class="link-offset-2 link-underline link-underline-opacity-0" href="#them3">Консольный ввод и вывод</a></li>
                                            <li class="list-group-item"><a class="link-offset-2 link-underline link-underline-opacity-0" href="#them4">Арифметические операции с числами</a></li>
                                            <li class="list-group-item"><a class="link-offset-2 link-underline link-underline-opacity-0" href="#them5">Поразрядные операции с числами</a></li>
                                            <li class="list-group-item"><a class="link-offset-2 link-underline link-underline-opacity-0" href="#them6">Условные выражения</a></li>
                                            <li class="list-group-item"><a class="link-offset-2 link-underline link-underline-opacity-0" href="#them7">Условная конструкция if</a></li>
                                            <li class="list-group-item"><a class="link-offset-2 link-underline link-underline-opacity-0" href="#them8">Циклы</a></li>
                                            <li class="list-group-item"><a class="link-offset-2 link-underline link-underline-opacity-0" href="#them9">Функции</a></li>
                                            <li class="list-group-item"><a class="link-offset-2 link-underline link-underline-opacity-0" href="#them10">Параметры функции</a></li>
                                            <li class="list-group-item"><a class="link-offset-2 link-underline link-underline-opacity-0" href="#them11">Оператор return и возвращение результата из функции</a></li>
                                            <li class="list-group-item"><a class="link-offset-2 link-underline link-underline-opacity-0" href="#them12">Функция как тип, параметр и результат другой функции</a></li>
                                            <li class="list-group-item"><a class="link-offset-2 link-underline link-underline-opacity-0" href="#them13">Лямбда-выражения</a></li>
                                            <li class="list-group-item"><a class="link-offset-2 link-underline link-underline-opacity-0" href="#them14">Преобразование типов</a></li>
                                            <li class="list-group-item"><a class="link-offset-2 link-underline link-underline-opacity-0" href="#them15">Область видимости переменных</a></li>
                                            <li class="list-group-item"><a class="link-offset-2 link-underline link-underline-opacity-0" href="#them16">Замыкания</a></li>
                                            <li class="list-group-item"><a class="link-offset-2 link-underline link-underline-opacity-0" href="#them17">Декораторы</a></li>
                                        </ul>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                    <div class="card" style="width: 18rem;">
                        <div class="card-body">
                            <h5 class="card-title">Глава 3. Объектно-ориентированное программирование</h5>
                            <div class="accordion-item">
                                <h6 class="accordion-header">
                                    <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse"
                                        data-bs-target="#flush-collapse2" aria-expanded="false"
                                        aria-controls="flush-collapse2">
                                        Темы раздела
                                    </button>
                                </h6>
                                <div id="flush-collapse2" class="accordion-collapse collapse"
                                    data-bs-parent="#accordionFlushExample">
                                    <div class="accordion-body">
                                        <ul class="list-group">
                                            <li class="list-group-item"><a class="link-offset-2 link-underline link-underline-opacity-0" href="pageThem2.html#them1">Классы и объекты</a></li>
                                            <li class="list-group-item"><a class="link-offset-2 link-underline link-underline-opacity-0" href="pageThem2.html#them2">Инкапсуляция, атрибуты и свойства</a></li>
                                            <li class="list-group-item"><a class="link-offset-2 link-underline link-underline-opacity-0" href="pageThem2.html#them3">Наследование</a></li>
                                            <li class="list-group-item"><a class="link-offset-2 link-underline link-underline-opacity-0" href="pageThem2.html#them4">Переопределение функционала базового класса</a></li>
                                            <li class="list-group-item"><a class="link-offset-2 link-underline link-underline-opacity-0" href="pageThem2.html#them5">Атрибуты классов и статические методы</a></li>
                                            <li class="list-group-item"><a class="link-offset-2 link-underline link-underline-opacity-0" href="pageThem2.html#them6">Класс object. Строковое представление объекта</a></li>
                                            <li class="list-group-item"><a class="link-offset-2 link-underline link-underline-opacity-0" href="pageThem2.html#them7">Перегрузка операторов</a></li>
                                            <li class="list-group-item"><a class="link-offset-2 link-underline link-underline-opacity-0" href="pageThem2.html#them8">Абстрактные классы и методы</a></li>
                                        </ul>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                    <div class="card" style="width: 18rem;">
                        <div class="card-body">
                            <h5 class="card-title">Глава 4. Обработка ошибок и исключений</h5>
                            <div class="accordion-item">
                                <h6 class="accordion-header">
                                    <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse"
                                        data-bs-target="#flush-collapse3" aria-expanded="false"
                                        aria-controls="flush-collapse3">
                                        Темы раздела
                                    </button>
                                </h6>
                                <div id="flush-collapse3" class="accordion-collapse collapse"
                                    data-bs-parent="#accordionFlushExample">
                                    <div class="accordion-body">
                                        <ul class="list-group">
                                            <li class="list-group-item"><a class="link-offset-2 link-underline link-underline-opacity-0" href="pageThem3.html#them1">Конструкция try...except...finally</a></li>
                                            <li class="list-group-item"><a class="link-offset-2 link-underline link-underline-opacity-0" href="pageThem3.html#them2">except и обработка разных типов исключений</a></li>
                                            <li class="list-group-item"><a class="link-offset-2 link-underline link-underline-opacity-0" href="pageThem3.html#them3">Генерация исключений и создание своих типов исключений</a></li>
                                        </ul>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                    <div class="card" style="width: 18rem;">
                        <div class="card-body">
                            <h5 class="card-title">Глава 5. Списки, кортежи и словари</h5>
                            <div class="accordion-item">
                                <h6 class="accordion-header">
                                    <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse"
                                        data-bs-target="#flush-collapse4" aria-expanded="false"
                                        aria-controls="flush-collapse4">
                                        Темы раздела
                                    </button>
                                </h6>
                                <div id="flush-collapse4" class="accordion-collapse collapse"
                                    data-bs-parent="#accordionFlushExample">
                                    <div class="accordion-body">
                                        <ul class="list-group">
                                            <li class="list-group-item"><a class="link-offset-2 link-underline link-underline-opacity-0" href="pageThem4.html#them1">Списки</a></li>
                                            <li class="list-group-item"><a class="link-offset-2 link-underline link-underline-opacity-0" href="pageThem4.html#them2">Кортежи</a></li>
                                            <li class="list-group-item"><a class="link-offset-2 link-underline link-underline-opacity-0" href="pageThem4.html#them3">Диапазоны</a></li>
                                            <li class="list-group-item"><a class="link-offset-2 link-underline link-underline-opacity-0" href="pageThem4.html#them4">Словари</a></li>
                                            <li class="list-group-item"><a class="link-offset-2 link-underline link-underline-opacity-0" href="pageThem4.html#them5">Множества</a></li>
                                            <li class="list-group-item"><a class="link-offset-2 link-underline link-underline-opacity-0" href="pageThem4.html#them6">List comprehension</a></li>
                                            <li class="list-group-item"><a class="link-offset-2 link-underline link-underline-opacity-0" href="pageThem4.html#them7">Упаковка и распаковка</a></li>
                                            <li class="list-group-item"><a class="link-offset-2 link-underline link-underline-opacity-0" href="pageThem4.html#them8">Упаковка и распаковка в параметрах функций</a></li>
                                        </ul>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                    <div class="card" style="width: 18rem;">
                        <div class="card-body">
                            <h5 class="card-title">Глава 6. Модули</h5>
                            <div class="accordion-item">
                                <h6 class="accordion-header">
                                    <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse"
                                        data-bs-target="#flush-collapse5" aria-expanded="false"
                                        aria-controls="flush-collapse5">
                                        Темы раздела
                                    </button>
                                </h6>
                                <div id="flush-collapse5" class="accordion-collapse collapse"
                                    data-bs-parent="#accordionFlushExample">
                                    <div class="accordion-body">
                                        <ul class="list-group">
                                            <li class="list-group-item"><a class="link-offset-2 link-underline link-underline-opacity-0" href="pageThem5.html#them1">Определение и подключение модулей</a></li>
                                            <li class="list-group-item"><a class="link-offset-2 link-underline link-underline-opacity-0" href="pageThem5.html#them2">Генерация байткода модулей</a></li>
                                            <li class="list-group-item"><a class="link-offset-2 link-underline link-underline-opacity-0" href="pageThem5.html#them3">Модуль random</a></li>
                                            <li class="list-group-item"><a class="link-offset-2 link-underline link-underline-opacity-0" href="pageThem5.html#them4">Модуль secrets</a></li>
                                            <li class="list-group-item"><a class="link-offset-2 link-underline link-underline-opacity-0" href="pageThem5.html#them5">Математические функции и модуль math</a></li>
                                            <li class="list-group-item"><a class="link-offset-2 link-underline link-underline-opacity-0" href="pageThem5.html#them6">Модуль locale</a></li>
                                            <li class="list-group-item"><a class="link-offset-2 link-underline link-underline-opacity-0" href="pageThem5.html#them7">Модуль decimal</a></li>
                                            <li class="list-group-item"><a class="link-offset-2 link-underline link-underline-opacity-0" href="pageThem5.html#them8">Модуль dataclasses. Data-классы</a></li>
                                            <li class="list-group-item"><a class="link-offset-2 link-underline link-underline-opacity-0" href="pageThem5.html#them9">Модуль timeit</a></li>
                                            <li class="list-group-item"><a class="link-offset-2 link-underline link-underline-opacity-0" href="pageThem5.html#them10">Установка пакетов, pip и виртуальная среда</a></li>
                                        </ul>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            <div class="col-9 m-2">
                <h3>Основы Python</h3>
                <div id="them1">
                    <h4>Введение в написание программ</h4>
                    <p>Программа на языке Python состоит из набора инструкций. Каждая инструкция помещается на новую строку. Например:</p>
                    <img src="" alt="">
                    <p>Большую роль в Python играют отступы. Неправильно поставленный отступ фактически является ошибкой. Например, в следующем случае мы получим ошибку, хотя код будет практически аналогичен приведенному выше:</p>
                    <img src="" alt="">
                    <p>Поэтому стоит помещать новые инструкции сначала строки. В этом одно из важных отличий пайтона от других языков программирования, как C# или Java.</p>
                    <p>Однако стоит учитывать, что некоторые конструкции языка могут состоять из нескольких строк. Например, условная конструкция if:</p>
                    <img src="" alt="">
                    <p>В данном случае если 1 меньше 2, то выводится строка "Hello". И здесь уже должен быть отступ, так как инструкция print("Hello") используется не сама по себе, а как часть условной конструкции if. Причем отступ, согласно руководству по оформлению кода, желательно делать из такого количество пробелов, которое кратно 4 (то есть 4, 8, 16 и т.д.) Хотя если отступов будет не 4, а 5, то программа также будет работать.</p>
                    <p>Таких конструкций не так много, поэтому особой путаницы по поводу где надо, а где не надо ставить пробелы, не должно возникнуть.</p>
                    <p>Регистрозависимость</p>
                    <p>Python - регистрозависимый язык, поэтому выражения print и Print или PRINT представляют разные выражения. И если вместо метода print для вывода на консоль мы попробуем использовать метод Print:</p>
                    <img src="" alt="">
                    <p>Комментарии</p>
                    <p>Для отметки, что делает тот или иной участок кода, применяются комментарии. При трансляции и выполнении программы интерпретатор игнорирует комментарии, поэтому они не оказывают никакого влияния на работу программы. Комментарии в Python бывают блочные и строчные.</p>
                    <p>Строчные коментарии предваряются знаком решетки - #. Они могут располагаться на отдельной строке:</p>
                    <img src="" alt="">
                    <p>Любой набор символов после знака # представляет комментарий. То есть в примере выше первые две строки кода являются комментариями.</p>
                    <p>Также они могут располагаться на той же строке, что и инструкции языка, после выполняемых инструкций:</p>
                    <img src="" alt="">
                    <p>В блочных коментариях до и после текста комментария ставятся три одинарные кавычки: '''текст комментария'''. Например:</p>
                    <img src="" alt="">
                    <p>Основные функции</p>
                    <p>Python предоставляет ряд встроенных функций. Некоторые из них используются очень часто, особенно на начальных этапах изучения языка, поэтому рассмотрим их.</p>
                    <p>Основной функцией для вывода информации на консоль является функция print(). В качестве аргумента в эту функцию передается строка, которую мы хотим вывести:</p>
                    <img src="" alt="">
                    <p>Если же нам необходимо вывести несколько значений на консоль, то мы можем передать их в функцию print через запятую:</p>
                    <img src="" alt="">
                    <p>В итоге все переданные значения склеятся через пробелы в одну строку:</p>
                    <img src="" alt="">
                    <p>Если функция print отвечает за вывод, то функция input отвечает за ввод информации. В качестве необязательного параметра эта функция принимает приглашение к вводу и возвращает введенную строку, которую мы можем сохранить в переменную:</p>
                    <img src="" alt="">
                    <p>Консольный вывод:</p>
                    <img src="" alt="">
                </div>
                <div id="them2">
                    <h4>Переменные и типы данных</h4>
                    <p>Переменные</p>
                    <p>Переменные предназначены для хранения данных. Название переменной в Python должно начинаться с алфавитного символа или со знака подчеркивания и может содержать алфавитно-цифровые символы и знак подчеркивания. И кроме того, название переменной не должно совпадать с названием ключевых слов языка Python. Ключевых слов не так много, их легко запомнить:</p>
                    <img src="" alt="">
                    <p>Например, создадим переменную:</p>
                    <img src="" alt="">
                    <p>Здесь определена переменная name, которая хранит строку "Tom".</p>
                    <p>В пайтоне применяется два типа наименования переменных: camel case и underscore notation.</p>
                    <p>Camel case подразумевает, что каждое новое подслово в наименовании переменной начинается с большой буквы. Например:</p>
                    <img src="" alt="">
                    <p>Underscore notation подразумевает, что подслова в наименовании переменной разделяются знаком подчеркивания. Например:</p>
                    <img src="" alt="">
                    <p>И также надо учитывать регистрозависимость, поэтому переменные name и Name будут представлять разные объекты.</p>
                    <img src="" alt="">
                    <p>Определив переменную, мы можем использовать в программе. Например, попытаться вывести ее содержимое на консоль с помощью встроенной функции print:</p>
                    <img src="" alt="">
                    <p>Например, определение и применение переменной в среде PyCharm:</p>
                    <p>Переменные в Python</p>
                    <p>Отличительной особенностью переменной является то, что мы можем менять ее значение в течение работы программы:</p>
                    <img src="" alt="">
                    <p>Типы данных</p>
                    <p>Переменная хранит данные одного из типов данных. В Python существует множество различных типов данных. В данном случае рассмотрим только самые базовые типы: bool, int, float, complex и str.</p>
                    <p>Логические значения</p>
                    <p>Тип bool представляет два логических значения: True (верно, истина) или False (неверно, ложь). Значение True служит для того, чтобы показать, что что-то истинно. Тогда как значение False, наоборот, показывает, что что-то ложно. Пример переменных данного типа:</p>
                    <img src="" alt="">
                    <p>Целые числа</p>
                    <p>Тип int представляет целое число, например, 1, 4, 8, 50. Пример</p>
                    <img src="" alt="">
                    <p>По умолчанию стандартные числа расцениваются как числа в десятичной системе. Но Python также поддерживает числа в двоичной, восьмеричной и шестнадцатеричной системах.</p>
                    <p>Для указания, что число представляет двоичную систему, перед числом ставится префикс 0b:</p>
                    <img src="" alt="">
                    <p>Для указания, что число представляет восьмеричную систему, перед числом ставится префикс 0o:</p>
                    <img src="" alt="">
                    <p>Для указания, что число представляет шестнадцатеричную систему, перед числом ставится префикс 0x:</p>
                    <img src="" alt="">
                    <p>Стоит отметить, что в какой-бы системе мы не передали число в функцию print для вывода на консоль, оно по умолчанию будет выводиться в десятичной системе.</p>
                    <p>Дробные числа</p>
                    <p>Тип float представляет число с плавающей точкой, например, 1.2 или 34.76. В качесте разделителя целой и дробной частей используется точка.</p>
                    <img src="" alt="">
                    <p>Число с плавающей точкой можно определять в экспоненциальной записи:</p>
                    <img src="" alt="">
                    <p>Число float может иметь только 18 значимых символов. Так, в данном случае используются только два символа - 3.9. И если число слишком велико или слишком мало, то мы можем записывать число в подобной нотации, используя экспоненту. Число после экспоненты указывает степень числа 10, на которое надо умножить основное число - 3.9.</p>
                    <p>Комплексные числа</p>
                    <p>Тип complex представляет комплексные числа в формате вещественная_часть+мнимая_частьj - после мнимой части указывается суффикс j</p>
                    <img src="" alt="">
                    <p>Строки</p>
                    <p>Тип str представляет строки. Строка представляет последовательность символов, заключенную в одинарные или двойные кавычки, например "hello" и 'hello'. В Python 3.x строки представляют набор символов в кодировке Unicode</p>
                    <img src="" alt="">
                    <p>При этом, если строка имеет много символов, ее можно разбить на части и эти части разместить на разных строках кода. В этом случае вся строка заключается в круглые скобки, а ее отдельные части - в кавычки:</p>
                    <img src="" alt="">
                    <p>Если же мы хотим определить многострочный текст, то такой текст заключается в тройные двойные или одинарные кавычки:</p>
                    <img src="" alt="">
                    <p>При использовани тройных одинарных кавычек не стоит путать их с комментариями: если текст в тройных одинарных кавычках присваивается переменной, то это строка, а не комментарий.</p>
                    <p>Управляющие последовательности в строке</p>
                    <p>Строка может содержать ряд специальных символов - управляющих последовательностей. Некоторые из них:</p>
                    <p>\\: позволяет добавить внутрь строки слеш</p>
                    <p>\': позволяет добавить внутрь строки одинарную кавычку</p>
                    <p>\": позволяет добавить внутрь строки двойную кавычку</p>
                    <p>\n: осуществляет переход на новую строку</p>
                    <p>\t: добавляет табуляцию (4 отступа)</p>
                    <p>Применим несколько последовательностей:</p>
                    <img src="" alt="">
                    <p>Консольный вывод программы:</p>
                    <img src="" alt="">
                    <p>Хотя подобные последовательности могут нам помочь в некоторых делах, например, поместить в строку кавычку, сделать табуляцию, перенос на другую строку. Но они также могут и мешать. Например:</p>
                    <img src="" alt="">
                    <p>Здесь переменная path содержит некоторый путь к файлу. Однако внутри строки встречаются символы "\n", которые будут интерпретированы как управляющая последовательность. Так, мы получим следующий консольный вывод:</p>
                    <img src="" alt="">
                    <p>Чтобы избежать подобной ситуации, перед строкой ставится символ r</p>
                    <img src="" alt="">
                    <p>Вставка значений в строку</p>
                    <p>Python позволяет встравивать в строку значения других переменных. Для этого внутри строки переменные размещаются в фигурных скобках {}, а перед всей строкой ставится символ f:</p>
                    <img src="" alt="">
                    <p>В данном случае на место {userName} будет вставляться значение переменной userName. Аналогично на вместо {userAge} будет вставляться значение переменной userAge.</p>
                    <p>Динамическая типизация</p>
                    <p>Python является языком с динамической типизацией. А это значит, что переменная не привязана жестко к определенному типу.</p>
                    <p>Тип переменной определяется исходя из значения, которое ей присвоено. Так, при присвоении строки в двойных или одинарных кавычках переменная имеет тип str. При присвоении целого числа Python автоматически определяет тип переменной как int. Чтобы определить переменную как объект float, ей присваивается дробное число, в котором разделителем целой и дробной части является точка.</p>
                    <p>При этом в процессе работы программы мы можем изменить тип переменной, присвоив ей значение другого типа:</p>
                    <img src="" alt="">
                    <p>С помощью встроенной функции type() динамически можно узнать текущий тип переменной:</p>
                    <img src="" alt="">
                </div>
                <div id="them3">
                    <h4>Консольный ввод и вывод</h4>
                    <p>Вывод на консоль</p>
                    <p>Для вывода информации на консоль предназначена встроенная функция print(). При вызове этой функции ей в скобках передается выводимое значение:</p>
                    <img src="" alt="">
                    <p>Данный код выведет нам на консоль строку "Hello METANIT.COM".</p>
                    <p></p>
                    <p>Отличительной особенностью этой функции является то, что по умолчанию она выводит значение на отдельной строке. Например:</p>
                    <img src="" alt="">
                    <p>Здесь три вызова функции print() выводят некоторое сообщение. Причем при выводе на консоль каждое сообщение будет размещаться на отдельной строке:</p>
                    <img src="" alt="">
                    <p>Такое поведение не всегда удобно. Например, мы хотим, чтобы все значения выводились на одной строке. Для этого нам надо настроить поведение функции с помощью параметра end. Этот параметр задает символы, которые добавляются в конце к выводимой строке и . При применении параметра end вызов функции print() выглядит следующим образом:</p>
                    <img src="" alt="">
                    <p>По умолчанию end равен символу "\n", который задает перевод на следующую строку. Собственно поэтому функция print по умолчанию выводит передаваемое ей значение на отдельной строке.</p>
                    <p></p>
                    <p>Теперь определим, чтобы функция не делала перевод на следующую строку, а выводила значение на той же строке:</p>
                    <img src="" alt="">
                    <p>То есть теперь выводимые значения будут разделяться пробелом:</p>
                    <img src="" alt="">
                    <p>Причем это может быть не один символ, а набор символов:</p>
                    <img src="" alt="">
                    <p>В данном случае выводимые сообщения будут отделяться символами " and ":</p>
                    <img src="" alt="">
                    <p>Консольный ввод</p>
                    <p>Наряду с выводом на консоль мы можем получать ввод пользователя с консоли, получать вводимые данные. Для этого в Python определена функция input(). В эту функцию передается приглашение к вводу. А результат ввода мы можем сохранить в переменную. Например, определим код для ввода пользователем имени:</p>
                    <img src="" alt="">
                    <p>В данном случае в функцию input() передается приглашение к вводу в виде строки "Введите свое имя: ". Результат функции - результат ввода пользователя передается в переменную name. Затем мы можем вывести значение этой переменной на консоль с помощью функции print(). Пример работы кода:</p>
                    <img src="" alt="">
                    <p>Еще пример с вводом нескольких значений:</p>
                    <img src="" alt="">
                    <p>Пример работы программы:</p>
                    <img src="" alt="">
                    <p>Стоит учитывать, что все введенные значения рассматриваются как значения типа str, то есть строки. И даже если мы вводим число, как в втором случае в коде выше, то Python все равно будет рассматривать введенное значение как строку, а не как число.</p>
                </div>
                <div id="them4">
                    <h4>Арифметические операции с числами</h4>
                    <p>Python поддерживает все распространенные арифметические операции:</p>
                    <ul class="list-group">
                        <li class="list-group-item"><p>Сложение двух чисел:</p></li>
                        <li class="list-group-item"><p>Вычитание двух чисел:</p></li>
                        <li class="list-group-item"><p>Умножение двух чисел:</p></li>
                        <li class="list-group-item"><p>Деление двух чисел:</p></li>
                        <li class="list-group-item"><p>Целочисленное деление двух чисел:</p></li>
                        <li class="list-group-item"><p>Возведение в степень:</p></li>
                        <li class="list-group-item"><p>Получение остатка от деления:</p></li>
                    </ul>
                    <p>При последовательном использовании нескольких арифметических операций их выполнение производится в соответствии с их приоритетом. В начале выполняются операции с большим приоритетом.</p>
                    <p>Пусть у нас выполняется следующее выражение:</p>
                    <img src="" alt="">
                    <p>Здесь начале выполняется возведение в степень (5 ** 2) как операция с большим приоритетом, далее результат умножается на 4 (25 * 4), затем происходит сложение (3 + 100) и далее опять идет сложение (103 + 7).</p>
                    <p></p>
                    <p>Чтобы переопределить порядок операций, можно использовать скобки:</p>
                    <img src="" alt="">
                    <p>Следует отметить, что в арифметических операциях могут принимать участие как целые, так и дробные числа. Если в одной операции участвует целое число (int) и число с плавающей точкой (float), то целое число приводится к типу float.</p>
                    <p></p>
                    <p>Арифметические операции с присвоением</p>
                    <p>Ряд специальных операций позволяют использовать присвоить результат операции первому операнду:</p>
                    <ul class="list-group">
                        <li class="list-group-item"><p>Присвоение результата сложения</p></li>
                        <li class="list-group-item"><p>Присвоение результата вычитания</p></li>
                        <li class="list-group-item"><p>Присвоение результата умножения</p></li>
                        <li class="list-group-item"><p>Присвоение результата от деления</p></li>
                        <li class="list-group-item"><p>Присвоение результата целочисленного деления</p></li>
                        <li class="list-group-item"><p>Присвоение степени числа</p></li>
                        <li class="list-group-item"><p>Присвоение остатка от деления</p></li>
                    </ul>
                    <p>Примеры операций:</p>
                    <img src="" alt="">
                    <p>Округление и функция round</p>
                    <p>При операциях с числами типа float надо учитывать, что результат операций с ними может быть не совсем точным. Например:</p>
                    <img src="" alt="">
                    <p>В данном случае мы ожидаем получить число 0.40002, однако в конце через ряд нулей появляется еще какая-то четверка. Или еще одно выражение:</p>
                    <img src="" alt="">
                    <p>В случае выше для округления результата мы можем использовать встроенную функцию round():</p>
                    <img src="" alt="">
                    <p>В функцию round() передается число, которое надо округлить. Если в функцию передается одно число, как в примере выше, то оно округляется до целого.</p>
                    <p></p>
                    <p>Функция round() также может принимать второе число, которое указывает, сколько знаков после запятой должно содержать получаемое число:</p>
                    <img src="" alt="">
                    <p>В данном случае число third_number округляется до 4 знаков после запятой.</p>
                    <p></p>
                    <p>Если в функцию передается только одно значение - только округляемое число, оно округляется то ближайшего целого</p>
                    <p></p>
                    <p>Примеры округлений:</p>
                    <img src="" alt="">
                    <p>Однако если округляемая часть равна одинаково удалена от двух целых чисел, то округление идет к ближайшему четному:</p>
                    <img src="" alt="">
                    <p>Округление производится до ближайшего кратного 10 в степени минус округляемая часть:</p>
                    <img src="" alt="">
                    <p>Однако следует учитывать, что функция round() не идеальный инструмент. Например, выше при округление до целых чисел применяется правило, согласно которому, если округляемая часть одинаково удалена от двух значений, то округление производится до ближайшего четного значения. В Python в связи с тем, что десятичная часть числа не может быть точно представлена в виде числа float, то это может приводить к некоторым не совсем ожидаемым результатам. Например:</p>
                    <img src="" alt="">
                </div>
                <div id="them5">
                    <h4>Поразрядные операции с числами</h4>
                    <p>Особый класс операций представляют поразрядные операции. Они выполняются над отдельными разрядами чисел типа int. Но чтобы понять природу поразрядных операций, надо понимать что вообще представляет число в двоичном представление.</p>
                    <p>Двоичное представление чисел</p>
                    <p>При двоичной системе каждый разряд числа может иметь только два значения - 0 и 1. Например, 0 в десятичной системе также будет равен 0 в двоичной системе, а 1 в десятичной системе будет соответствовать 1 в двоичной системе. Следующее число в десятичной системе - 2 в двоичной системе будет соответствовать 10. То есть, когда мы к 1 прибавляем 1, то результатом будет 10. И так далее.</p>
                    <p>Например, 5 в двоичном представлении 101 и имеет три разряда. Для вывода десятичного числа в двоичной системе можно применять спецификатор 0b:</p>
                    <img src="" alt="">
                    <p>Без указания спецификатора функция print() выводит число в десятичной системе.</p>
                    <p>При этом Python позволяет сразу определять число в двоичной форме. Для этого число в двоичной форме указывается после префикса 0b:</p>
                    <img src="" alt="">
                    <p>Еще несколько примеров сопоставления между двоичной и десятичной системами:</p>
                    <img src="" alt="">
                    <p>Логические операции</p>
                    <p>Логические операции выполняются над отдельными разрядами числа. В Python есть следующие логические операции:</p>
                    <p>&(логическое умножение)</p>
                    <p>Умножение производится поразрядно, и если у обоих операндов значения разрядов равно 1, то операция возвращает 1, иначе возвращается число 0. Например:</p>
                    <img src="" alt="">
                    <p>В первом случае у нас два числа 2 и 5. 2 в двоичном виде представляет число 010, а 5 - 101. Поразрядно умножим числа (0*1, 1*0, 0*1) и в итоге получим 000.</p>
                    <p>Во втором случае у нас вместо двойки число 4, у которого в первом разряде 1, так же как и у числа 5, поэтому в итоге получим (1*1, 0*0, 0 *1) = 100, то есть число 4 в десятичном формате.</p>
                    <p>| (логическое сложение)</p>
                    <p>Похоже на логическое умножение, операция также производится по двоичным разрядам, но теперь возвращается единица, если хотя бы у одного числа в данном разряде имеется единица. Например:</p>
                    <img src="" alt="">
                    <p>^ (логическое исключающее ИЛИ)</p>
                    <p>Если значения текущего разряда у обоих чисел разные, то возвращается 1, иначе возвращается 0. Также эту операцию называют XOR. Например:</p>
                    <img src="" alt="">
                    <p>Здесь число 9 в двоичной форме равно 1001. Число 5 равно 0101. Операция XOR дает следующий результат: 1^0, 0^1, 0^0, 1^1. Здесь мы видим, что первые два разряда чисел содержат разные значения, поэтому первые два разряда получат значение 1. А последние два разряда чисел содержат одинаковые значения, поэтому последние два разряда получат значение 0. Таким образом, мы получаем число 1100 или 12 в десятичной системе.</p>
                    <p>нередко данную операцию применяют для простого шифрования:</p>
                    <img src="" alt="">
                    <p>Также можно применять эту операцию для обмена значений чисел:</p>
                    <img src="" alt="">
                    <p>~(инверсия)</p>
                    <p>Инвертирует число. Выражение ~x фактически аналогично -(x+1). Например:</p>
                    <img src="" alt="">
                    <p>Операции сдвига</p>
                    <p>Операции сдвига также производятся над разрядами чисел. Сдвиг может происходить вправо и влево.</p>
                    <p><code>x&lt;&lt;y</code> - сдвигает число x влево на y разрядов. Например, <code>4&lt;&lt;1</code> сдвигает число 4 (которое в двоичном представлении 100) на один разряд влево, то есть в итоге получается 1000 или число 8 в десятичном представлении.</p>
                    <p>x>>y - сдвигает число x вправо на y разрядов. Например, 16>>1 сдвигает число 16 (которое в двоичном представлении 10000) на один разряд вправо, то есть в итоге получается 1000 или число 8 в десятичном представлении.</p>
                    <p>Таким образом, если исходное число, которое надо сдвинуть в ту или другую строну, делится на два, то фактически получается умножение или деление на два. Поэтому подобную операцию можно использовать вместо непосредственного умножения или деления на два. Например:</p>
                    <img src="" alt="">
                    <p>При этом числа, которые участвую в операциях, необязательно должны быть кратны 2::</p>
                    <img src="" alt="">
                </div>
                <div id="them6">
                    <h4></h4>
                    <p>Ряд операций представляют условные выражения. Все эти операции принимают два операнда и возвращают логическое значение, которое в Python представляет тип bool. Существует только два логических значения - True (выражение истинно) и False (выражение ложно).</p>
                    <p>Операции сравнения</p>
                    <p>Простейшие условные выражения представляют операции сравнения, которые сравнивают два значения. Python поддерживает следующие операции сравнения:</p>
                    <p>==</p>
                    <p>Возвращает True, если оба операнда равны. Иначе возвращает False.</p>
                    <p>!=</p>
                    <p>Возвращает True, если оба операнда НЕ равны. Иначе возвращает False.</p>
                    <p>> (больше чем)</p>
                    <p>Возвращает True, если первый операнд больше второго.</p>
                    <p>&lt; (меньше чем)</p>
                    <p>Возвращает True, если первый операнд меньше второго.</p>
                    <p>>= (больше или равно)</p>
                    <p>Возвращает True, если первый операнд больше или равен второму.</p>
                    <p>&lt;= (меньше или равно)</p>
                    <p>Возвращает True, если первый операнд меньше или равен второму.</p>
                    <p>Примеры операций сравнения:</p>
                    <pre><code>
                    <p>a = 5</p>
                    <p>b = 6</p>
                    <p>result = 5 == 6  # сохраняем результат операции в переменную</p>
                    <p>print(result)  # False - 5 не равно 6</p>
                    <p>print(a != b)  # True</p>
                    <p>print(a > b)  # False - 5 меньше 6</p>
                    <p>print(a &lt; b)  # True</p>
                    <p> </p>
                    <p>bool1 = True</p>
                    <p>bool2 = False</p>
                    <p>print(bool1 == bool2)  # False - bool1 не равно bool2</p>
                    </code></pre>
                    <p>Операции сравнения могут сравнивать различные объекты - строки, числа, логические значения, однако оба операнда операции должны представлять один и тот же тип.</p>
                    <p>Логические операции</p>
                    <p>Для создания составных условных выражений применяются логические операции. В Python имеются следующие логические операторы:</p>
                    <p>Оператор and (логическое умножение) применяется к двум операндам:</p>
                    <p>x and y</p>
                    <p>Сначала оператор and оценивает выражение x, и если оно равно False, то возвращается его значение. Если оно равно True, то оценивается второй операнд - y и возвращается значение y.</p>
                    <pre><code>
                        <p>age = 22</p>
                        <p>weight = 58</p>
                        <p>result = age > 21 and weight == 58</p>
                        <p>print(result)  # True</p>
                    </code></pre>
                    <p>В данном случае оператор and сравнивает результаты двух выражений: age > 21 weight == 58. И если оба этих выражений возвращают True, то оператор and также возвращает True (формально возвращается значение последнего операнда).</p>
                    <p>Но операндами оператора and необязательно выступают значения True и False. Это могут быть любые значения. Например:</p>
                    <pre><code>
                        <p>result = 4 and "w"</p>
                        <p>print(result)  # w, так как 4 равно True, поэтому возвращается значение последнего операнда</p>
                        <p> </p>
                        <p>result = 0 and "w"</p>
                        <p>print(result)  # 0, так как 0 эквивалентно False</p>
                    </code></pre>
                    <p>В данном случае число 0 и пустая строка "" расматриваются как False, все остальные числа и непустые строки эквивалентны True</p>
                    <p>or (логическое сложение) также применяется к двум операндам:</p>
                    <p>x or y</p>
                    <p>Сначала оператор or оценивает выражение x, и если оно равно True, то возвращается его значение. Если оно равно False, то оценивается второй операнд - y и возвращается значение y. Например</p>
                    <pre><code>
                        <p>age = 22</p>
                        <p>isMarried = False</p>
                        <p>result = age > 21 or isMarried</p>
                        <p>print(result)  # True, так как выражение age > 21 равно True</p>
                    </code></pre>
                    <p>И также оператор or может применяться к любым значениям. Например:</p>
                    <pre><code>
                        <p>result = 4 or "w"</p>
                        <p>print(result)  # 4, так как 4 эквивалентно True, поэтому возвращается значение первого операнда</p>
                        <p> </p>
                        <p>result = 0 or "w"</p>
                        <p>print(result)  # w, так как 0 эквивалентно False, поэтому возвращается значение последнего операнда</p>
                    </code></pre>
                    <p>not (логическое отрицание)</p>
                    <p>Возвращает True, если выражение равно False</p>
                    <pre><code>
                        <p>age = 22</p>
                        <p>isMarried = False</p>
                        <p>print(not age > 21)  # False</p>
                        <p>print(not isMarried)  # True</p>
                        <p>print(not 4)  # False</p>
                        <p>print(not 0)  # True</p>
                    </code></pre>
                    <p>Оператор in</p>
                    <p>Оператор in возвращает True если в некотором наборе значений есть определенное значение. Он имеет следующую форму:</p>
                    <p>значение in набор_значений</p>
                    <p>Например, строка представляет набор символов. И с помощью оператора in мы можем проверить, есть ли в ней какая-нибудь подстрока:</p>
                    <pre><code>
                        <p>message = "hello world!"</p>
                        <p>hello = "hello"</p>
                        <p>print(hello in message)  # True - подстрока hello есть в строке "hello world!"</p>
                        <p> </p>
                        <p>gold = "gold"</p>
                        <p>print(gold in message)  # False - подстроки "gold" нет в строке "hello world!"</p>
                    </code></pre>
                    <p>Если нам надо наоборот проверить, нет ли в наборе значений какого-либо значения, то мы може использовать модификацию оператора - not in. Она возвращает True, если в наборе значений НЕТ определенного значения:</p>
                    <pre><code>
                        <p>message = "hello world!"</p>
                        <p>hello = "hello"</p>
                        <p>print(hello not in message)  # False</p>
                        <p> </p>
                        <p>gold = "gold"</p>
                        <p>print(gold not in message)  # True</p>
                    </code></pre>
                </div>
                <div id="them7">
                    <h4></h4>
                    <p>Условные конструкции используют условные выражения и в зависимости от их значения направляют выполнение программы по одному из путей. Одна из таких конструкций - это конструкция if. Она имеет следующее формальное определение:</p>
                    <pre><code>
                        <p>if логическое_выражение:</p>
                        <p>    инструкции</p>
                        <p>[elif логическое выражение:</p>
                        <p>    инструкции]</p>
                        <p>[else: </p>
                        <p>    инструкции]</p>
                    </code></pre>
                    <p>В самом простом виде после ключевого слова if идет логическое выражение. И если это логическое выражение возвращает True, то выполняется последующий блок инструкций, каждая из которых должна начинаться с новой строки и должна иметь отступы от начала выражения if (отступ желательно делать в 4 пробела или то количество пробелов, которое кратно 4):</p>
                    <pre><code>
                        <p>language = "english"</p>
                        <p>if language == "english":</p>
                        <p>    print("Hello")</p>
                        <p>print("End")</p>
                    </code></pre>
                    <p>Поскольку в данном случае значение переменной language равно "english", то будет выполняться блок if, который содержит только одну инструкцию - print("Hello"). В итоге консоль выведет следующие строки:</p>
                    <p>Hello</p>
                    <p>End</p>
                    <p>Обратите внимание в коде на последнюю строку, которая выводит сообщение "End". Она не имеет отступов от начала строки, поэтому она не принадлежит к блоку if и будет выполняться в любом случае, даже если выражение в конструкции if возвратит False.</p>
                    <p>Но если бы мы поставили бы отступы, то она также принадлежала бы к конструкции if:</p>
                    <pre><code>
                        <p>language = "english"</p>
                        <p>if language == "english":</p>
                        <p>    print("Hello")</p>
                        <p>    print("End")</p>
                    </code></pre>
                    <p>Блок else</p>
                    <p>Если вдруг нам надо определить альтернативное решение на тот случай, если выражение в if возвратит False, то мы можем использовать блок else:</p>
                    <pre><code>
                        <p>language = "russian"</p>
                        <p>if language == "english":</p>
                        <p>    print("Hello")</p>
                        <p>else:</p>
                        <p>    print("Привет")</p>
                        <p>print("End")</p>
                    </code></pre>
                    <p>Если выражение language == "english" возвращает True, то выполняется блок if, иначе выполняется блок else. И поскольку в данном случае условие language == "english" возвращает False, то будут выполняться инструкция из блока else.</p>
                    <p>Причем инструкции блока else также должны имет отступы от начала строки. Например, в примере выше print("End") не имеет отступа, поэтому она не входит в блок else и будет выполнятьься вне зависимости, чему равно условие language == "english". То есть консоль нам выведет следующие строки:</p>
                    <p>Привет</p>
                    <p>End</p>
                    <p>Блок else также может иметь несколько инструкций, которые должны иметь отступ от начала строки:</p>
                    <pre><code>
                        <p>language = "russian"</p>
                        <p>if language == "english":</p>
                        <p>    print("Hello")</p>
                        <p>    print("World")</p>
                        <p>else:</p>
                        <p>    print("Привет")</p>
                        <p>    print("мир")</p>
                        <p>elif</p>
                    </code></pre>
                    <p>Если необходимо ввести несколько альтернативных условий, то можно использовать дополнительные блоки elif, после которого идет блок инструкций.</p>
                    <pre><code>
                        <p>language = "german"</p>
                        <p>if language == "english":</p>
                        <p>    print("Hello")</p>
                        <p>    print("World")</p>
                        <p>elif language == "german":</p>
                        <p>    print("Hallo")</p>
                        <p>    print("Welt")</p>
                        <p>else:</p>
                        <p>    print("Привет")</p>
                        <p>    print("мир")</p>
                    </code></pre>
                    <p>Сначала Python проверяет выражение if. Если оно равно True, то выполняются инструкции из блока if. Если это условие возвращает False, то Python проверяет выражение из elif.</p>
                    <p>Если выражение после elif равно True, то выполняются инструкции из блока elif. Но если оно равно False то выполняются инструкции из блока else</p>
                    <p>При необходимости можно определить несколько блоков elif для разных условий. Например:</p>
                    <pre><code>
                        <p>language = "german"</p>
                        <p>if language == "english":</p>
                        <p>    print("Hello")</p>
                        <p>elif language == "german":</p>
                        <p>    print("Hallo")</p>
                        <p>elif language == "french":</p>
                        <p>    print("Salut")</p>
                        <p>else:</p>
                        <p>    print("Привет")</p>
                    </code></pre>
                    <p>Вложенные конструкции if</p>
                    <p>Конструкция if в свою очередь сама может иметь вложенные конструкции if:</p>
                    <pre><code>
                        <p>language = "english"</p>
                        <p>daytime = "morning"</p>
                        <p>if language == "english":</p>
                        <p>    print("English")</p>
                        <p>    if daytime == "morning":</p>
                        <p>        print("Good morning")</p>
                        <p>    else:</p>
                        <p>        print("Good evening")</p>
                    </code></pre>
                    <p>Здесь конструкция if содержит вложенную конструкцию if/else. То есть если переменная language равна "english", тогда вложенная конструкция if/else дополнительно проверяет значение переменной daytime - равна ли она строке "morning" ли нет. И в данном случае мы получим следующий консольный вывод:</p>
                    <p>English</p>
                    <p>Good morning</p>
                    <p>Стоит учитывать, что вложенные выражения if также должны начинаться с отступов, а инструкции во вложенных конструкциях также должны иметь отступы. Отступы, расставленные не должным образом, могут изменить логику программы. Так, предыдущий пример НЕ аналогичен следующему:</p>
                    <pre><code>    
                        <p>language = "english"</p>
                        <p>daytime = "morning"</p>
                        <p>if language == "english":</p>
                        <p>    print("English")</p>
                        <p>if daytime == "morning":</p>
                        <p>    print("Good morning")</p>
                        <p>else:</p>
                        <p>     print("Good evening")</p>
                    </code></pre>
                    <p>Подобным образом можно размещать вложенные конструкции if/elif/else в блоках elif и else:</p>
                    <pre><code>
                        <p>language = "russian"</p>
                        <p>daytime = "morning"</p>
                        <p>if language == "english":</p>
                        <p>    if daytime == "morning":</p>
                        <p>        print("Good morning")</p>
                        <p>    else:</p>
                        <p>        print("Good evening")</p>
                        <p>else:</p>
                        <p>    if daytime == "morning":</p>
                        <p>        print("Доброе утро")</p>
                        <p>    else:</p>
                        <p>        print("Добрый вечер")</p>
                    </code></pre>
                </div>
                <div id="them8">
                    <h4></h4>
                    <p>Циклы позволяют выполнять некоторое действие в зависимости от соблюдения некоторого условия. В языке Python есть следующие типы циклов:</p>
                    <p>while</p>
                    <p></p>
                    <p>for</p>
                    <p></p>
                    <p>Цикл while</p>
                    <p>Цикл while проверяет истинность некоторого условия, и если условие истинно, то выполняет инструкции цикла. Он имеет следующее формальное определение:</p>
                    <p>while условное_выражение:</p>
                    <p>   инструкции</p>
                    <p>После ключевого слова while указывается условное выражение, и пока это выражение возвращает значение True, будет выполняться блок инструкций, который идет далее.</p>
                    <p>Все инструкции, которые относятся к циклу while, располагаются на последующих строках и должны иметь отступ от начала ключевого слова while.</p>
                    <pre><code>
                        <p>number = 1</p>
                        <p> </p>
                        <p>while number &lt; 5:</p>
                        <p>    print(f"number = {number}")</p>
                        <p>    number += 1</p>
                        <p>print("Работа программы завершена")</p>
                    </code></pre>
                    <p>В данном случае цикл while будет выполняться, пока переменная number меньше 5.</p>
                    <p>Сам блок цикла состоит из двух инструкций:</p>
                    <pre><code>
                        <p>print(f"number = {number}")</p>
                        <p>number += 1</p>
                    </code></pre>
                    <p>Обратите внимание, что они имеют отступы от начала оператора while - в данном случае от начала строки. Благодаря этому Python может определить, что они принадлежат циклу. В самом цикле сначала выводится значение переменной number, а потом ей присваивается новое значение. .</p>
                    <p>Также обратите внимание, что последняя инструкция print("Работа программы завершена") не имеет отступов от начала строки, поэтому она не входит в цикл while.</p>
                    <p>Весь процесс цикла можно представить следующим образом:</p>
                    <p>Сначала проверяется значение переменной number - меньше ли оно 5. И поскольку вначале переменная равна 1, то это условие возвращает True, и поэтому выполняются инструкции цикла</p>
                    <p>Инструкции цикла выводят на консоль строку number = 1. И далее значение переменной number увеличивается на единицу - теперь она равна 2. Однократное выполнение блока инструкций цикла называется итерацией. То есть таким образом, в цикле выполняется первая итерация.</p>
                    <p>Снова проверяется условие number &lt; 5. Оно по прежнему равно True, так как number = 2, поэтому выполняются инструкции цикла</p>
                    <p>Инструкции цикла выводят на консоль строку number = 2. И далее значение переменной number опять увеличивается на единицу - теперь она равна 3. Таким образом, выполняется вторая итерация.</p>
                    <p>Опять проверяется условие number &lt; 5. Оно по прежнему равно True, так как number = 3, поэтому выполняются инструкции цикла</p>
                    <p>Инструкции цикла выводят на консоль строку number = 3. И далее значение переменной number опять увеличивается на единицу - теперь она равна 4. То есть выполняется третья итерация.</p>
                    <p>Снова проверяется условие number &lt; 5. Оно по прежнему равно True, так как number = 4, поэтому выполняются инструкции цикла</p>
                    <p>Инструкции цикла выводят на консоль строку number = 4. И далее значение переменной number опять увеличивается на единицу - теперь она равна 5. То есть выполняется четвертая итерация.</p>
                    <p>И вновь проверяется условие number &lt; 5. Но теперь оно равно False, так как number = 5, поэтому выполняются выход из цикла. Все цикл - завершился. Дальше уже выполняются действия, которые определены после цикла. Таким образом, данный цикл произведет четыре прохода или четыре итерации</p>
                    <p>В итоге при выполнении кода мы получим следующий консольный вывод:</p>
                    <p>number = 1</p>
                    <p>number = 2</p>
                    <p>number = 3</p>
                    <p>number = 4</p>
                    <p>Работа программы завершена</p>
                    <p>Для цикла while также можно определить дополнительный блок else, инструкции которого выполняются, когда условие равно False:</p>
                    <pre><code>
                        <p>number = 1</p>
                        <p> </p>
                        <p>while number &lt; 5:</p>
                        <p>    print(f"number = {number}")</p>
                        <p>    number += 1</p>
                        <p>else:</p>
                        <p>    print(f"number = {number}. Работа цикла завершена")</p>
                        <p>print("Работа программы завершена")</p>
                    </code></pre>
                    <p>То есть в данном случае сначала проверяется условие и выполняются инструкции while. Затем, когда условие становится равным False, выполняются инструкции из блока else. Обратите внимание, что инструкции из блока else также имеют отступы от начала конструкции цикла. В итоге в данном случае мы получим следующий консольный вывод:</p>
                    <p></p>
                    <p>number = 1</p>
                    <p>number = 2</p>
                    <p>number = 3</p>
                    <p>number = 4</p>
                    <p>number =5. Работа цикла завершена</p>
                    <p>Работа программы завершена</p>
                    <p>Блок else может быть полезен, если условие изначально равно False, и мы можем выполнить некоторые действия по этому поводу:</p>
                    <pre><code>
                        <p>number = 10</p>
                        <p> </p>
                        <p>while number < 5:</p>
                        <p>    print(f"number = {number}")</p>
                        <p>    number += 1</p>
                        <p>else:</p>
                        <p>    print(f"number = {number}. Работа цикла завершена")</p>
                        <p>print("Работа программы завершена")</p>
                    </code></pre>
                    <p>В данном случае условие number &lt; 5 изначально равно False, поэтому цикл не выполняет ни одной итерации и сразу переходит в блоку else.</p>
                    <p>Цикл for</p>
                    <p>Другой тип циклов представляет конструкция for. Этот цикл пробегается по набору значений, помещает каждое значение в переменную, и затем в цикле мы можем с этой переменной производить различные действия. Формальное определение цикла for:</p>
                    <p>for переменная in набор_значений:</p>
                    <p>    инструкции</p>
                    <p>После ключевого слова for идет название переменной, в которую будут помещаться значения. Затем после оператора in указывается набор значений и двоеточие.</p>
                    <p>А со следующей строки располагается блок инструкций цикла, которые также должны иметь отступы от начала цикла.</p>
                    <p>При выполнении цикла Python последовательно получает все значения из набора и передает их переменную. Когда все значения из набора будут перебраны, цикл завершает свою работу.</p>
                    <p>В качестве набора значений, например, можно рассматривать строку, которая по сути представляет набор символов. Посмотрим на примере:</p>
                    <pre><code>
                        <p>message = "Hello"</p>
                        <p> </p>
                        <p>for c in message:</p>
                        <p>    print(c)</p>
                    </code></pre>
                    <p>В цикле определяется переменную c, после оператора in в качестве перебираемого набора указана переменная message, которая хранит строку "Hello". В итоге цикл for будет перебираеть последовательно все символы из строки message и помещать их в переменную c. Блок самого цикла состоит из одной инструкции, которая выводит значение переменной с на консоль. Консольный вывод программы:</p>
                    <p>H</p>
                    <p>e</p>
                    <p>l</p>
                    <p>l</p>
                    <p>o</p>
                    <p>Нередко в связке с циклом for применяется встроенная функция range(), которая генерирует числовую последовательность:</p>
                    <pre><code>
                        <p>for n in range(10):</p>
                        <p>    print(n, end=" ")</p>
                    </code></pre>
                    <p>Если функцию range передается один параметр, то он означает максимальное значение диапазона чисел. В данном случае генерируется последовательность от 0 до 10 (не включительно). В итоге мы получим следующий консольный вывод:</p>
                    <p>0 1 2 3 4 5 6 7 8 9</p>
                    <p>Также в функцию range() можно передать минимальное значение диапазона</p>
                    <pre><code>
                        <p>for n in range(4, 10):</p>
                        <p>    print(n, end=" ")</p>
                    </code></pre>
                    <p>Здесь генерируется последовательность от 4 до 10 (не включая). Консольный вывод:</p>
                    <p>4 5 6 7 8 9</p>
                    <p>Также в функцию range() можно передать третий параметр, который указывает на приращение:</p>
                    <pre><code>
                        <p>for n in range(0, 10, 2):</p>
                        <p>    print(n, end=" ")</p>
                    </code></pre>
                    <p>Здесь генерируется последовательность от 0 до 10 (не включая) с приращением 2. Консольный вывод:</p>
                    <p>0 2 4 6 8</p>
                    <p>Цикл for также может иметь дополнительный блок else, который выполняется после завершения цикла:</p>
                    <pre><code>
                        <p>message = "Hello"</p>
                        <p>for c in message:</p>
                        <p>    print(c)</p>
                        <p>else:</p>
                        <p>    print(f"Последний символ: {c}. Цикл завершен");</p>
                        <p>print("Работа программы завершена")  # инструкция не имеет отступа, поэтому не относится к else</p>
                    </code></pre>
                    <p>В данном случае мы получим следующий консольный вывод:</p>
                    <p></p>
                    <p>H</p>
                    <p>e</p>
                    <p>l</p>
                    <p>l</p>
                    <p>o</p>
                    <p>Последний символ: o. Цикл завершен</p>
                    <p>Работа программы завершена</p>
                    <p>Стоит отметить, что блок else имеет доступ ко всем переменным, которые определены в цикле for.</p>
                    <p>Вложенные циклы</p>
                    <p>Одни циклы внутри себя могут содержать другие циклы. Рассмотрим на примере вывода таблицы умножения:</p>
                    <pre><code>
                        <p>i = 1</p>
                        <p>j = 1</p>
                        <p>while i &lt; 10:</p>
                        <p>    while j &lt; 10:</p>
                        <p>        print(i * j, end="\t")</p>
                        <p>        j += 1</p>
                        <p>    print("\n")</p>
                        <p>    j = 1</p>
                        <p>    i += 1</p>
                    </code></pre>
                    <p>Внешний цикл while i &lt; 10: срабатывает 9 раз пока переменная i не станет равна 10. Внутри этого цикла срабатывает внутренний цикл while j < 10:. Внутренний цикл также срабатывает 9 раз пока переменная j не станет равна 10. Причем все 9 итераций внутреннего цикла срабатывают в рамках одной итерации внешнего цикла.</p>
                    <p></p>
                    <p>В каждой итерации внутреннего цикла на консоль будет выводится произведение чисел i и j. Затем значение переменной j увеличивается на единицу. Когда внутренний цикл закончил работу, значений переменной j сбрасывается в 1, а значение переменной i увеличивается на единицу и происходит переход к следующей итерации внешнего цикла. И все повторяется, пока переменная i не станет равна 10. Соответственно внутренний цикл сработает всего 81 раз для всех итераций внешнего цикла. В итоге мы получим следующий консольный вывод:</p>
                    <p></p>
                    <p>1	2	3	4	5	6	7	8	9	</p>
                    <p></p>
                    <p>2	4	6	8	10	12	14	16	18	</p>
                    <p></p>
                    <p>3	6	9	12	15	18	21	24	27	</p>
                    <p></p>
                    <p>4	8	12	16	20	24	28	32	36	</p>
                    <p></p>
                    <p>5	10	15	20	25	30	35	40	45	</p>
                    <p></p>
                    <p>6	12	18	24	30	36	42	48	54	</p>
                    <p></p>
                    <p>7	14	21	28	35	42	49	56	63	</p>
                    <p></p>
                    <p>8	16	24	32	40	48	56	64	72	</p>
                    <p></p>
                    <p>9	18	27	36	45	54	63	72	81	</p>
                    <p>Подобным образом можно определять вложенные циклы for:</p>
                    <pre><code>
                        <p>for c1 in  "ab":</p>
                        <p>    for c2 in "ba":</p>
                        <p>        print(f"{c1}{c2}")</p>
                    </code></pre>
                    <p>В данном случае внешний цикл проходит по строке "ab" и каждый символ помещает в переменную c1. Внутренний цикл проходит по строке "ba", помещает каждый символ строки в переменную c2 и выводит сочетание обоих символов на консоль. То есть в итоге мы получим все возможные сочетания символов a и b:</p>
                    <p></p>
                    <p>ab</p>
                    <p>aa</p>
                    <p>bb</p>
                    <p>ba</p>
                    <p>Выход из цикла. break и continue</p>
                    <p>Для управления циклом мы можем использовать специальные операторы break и continue. Оператор break осуществляет выход из цикла. А оператор continue выполняет переход к следующей итерации цикла.</p>
                    <p></p>
                    <p>Оператор break может использоваться, если в цикле образуются условия, которые несовместимы с его дальнейшим выполнением. Рассмотрим следующий пример:</p>
                    <pre><code>
                        <p>number = 0</p>
                        <p>while number &lt; 5:</p>
                        <p>    number += 1</p>
                        <p>    if number == 3 :    # если number = 3, выходим из цикла</p>
                        <p>        break</p>
                        <p>    print(f"number = {number}")</p>
                    </code></pre>
                    <p>Здесь цикл while проверяет условие number &lt; 5. И пока number не равно 5, предполагается, что значение number будет выводиться на консоль. Однако внутри цикла также проверяется другое условие: if number == 3. То есть, если значение number равно 3, то с помощью оператора break выходим из цикла. И в итоге мы получим следующий консольный вывод:</p>
                    <p></p>
                    <p>number = 1</p>
                    <p>number = 2</p>
                    <p>В отличие от оператора break оператор continue выполняет переход к следующей итерации цикла без его завершения. Например, в предыдущем примере заменим break на continue:</p>
                    <pre><code>
                        <p>number = 0</p>
                        <p>while number &lt; 5:</p>
                        <p>    number += 1</p>
                        <p>    if number == 3 :    # если number = 3, переходим к новой итерации цикла</p>
                        <p>        continue</p>
                        <p>    print(f"number = {number}")</p>
                    </code></pre>
                    <p>И в этом случае если значение переменной number равно 3, последующие инструкции после оператора continue не будут выполняться:</p>
                    <p></p>
                    <p>number = 1</p>
                    <p>number = 2</p>
                    <p>number = 4</p>
                    <p>number = 5</p>
                </div>
                <div id="them9">
                    <h4></h4>
                    <p>Функции представляют блок кода, который выполняет определенную задачу и который можно повторно использовать в других частях программы. В предыдущих статьях уже использовались функции. В частности, функция print(), которая выводит некоторое значение на консоль. Python имеет множество встроенных функций и позволяет определять свои функции. Формальное определение функции:</p>
                    <p>def имя_функции ([параметры]):</p>
                    <p>    инструкции</p>
                    <p>Определение функции начинается с выражения def, которое состоит из имени функции, набора скобок с параметрами и двоеточия. Параметры в скобках необязательны. А со следующей строки идет блок инструкций, которые выполняет функция. Все инструкции функции имеют отступы от начала строки.</p>
                    <p></p>
                    <p>Например, определение простейшей функции:</p>
                    <pre><code>
                        <p>def say_hello():</p>
                        <p>    print("Hello")</p>
                    </code></pre>
                    <p>Функция называется say_hello. Она не имеет параметров и содержит одну единственную инструкцию, которая выводит на консоль строку "Hello".</p>
                    <p></p>
                    <p>Обратите внимание, что инструкции функции должны иметь отступы от начала функции. Например:</p>
                    <pre><code>
                        <p>def say_hello():</p>
                        <p>    print("Hello")</p>
                        <p> </p>
                        <p> </p>
                        <p>print("Bye")</p>
                    </code></pre>
                    <p>Здесь инструкция print("Bye") не имеет отступов от начала функции say_hello и поэтому в эту функцию не входит. Обычно между определением функции и остальными инструкциями, которые не входят в функцию, располагаются две пустых строки.</p>
                    <p>Для вызова функции указывается имя функции, после которого в скобках идет передача значений для всех ее параметров:</p>
                    <p>имя_функции ([параметры])</p>
                    <p>Например, определим и вызовем функцию:</p>
                    <pre><code>
                        <p>def say_hello():    # определение функции say_hello</p>
                        <p>    print("Hello")</p>
                        <p> </p>
                        <p> </p>
                        <p>say_hello()         # вызов функции say_hello</p>
                        <p>say_hello()</p>
                        <p>say_hello()</p>
                    </code></pre>
                    <p>Здесь три раза подряд вызывается функция say_hello. В итоге мы получим следующий консольный вывод:</p>
                    <p></p>
                    <p>Hello</p>
                    <p>Hello</p>
                    <p>Hello</p>
                    <p>Обратите внимание, что функция сначала определяется, а потом вызывается.</p>
                    <p>Если функция имеет одну инструкцию, то ее можно разместить на одной строке с остальным определением функции:</p>
                    <pre><code>
                        <p>def say_hello(): print("Hello")</p>
                        <p> </p>
                        <p>say_hello()</p>
                    </code></pre>
                    <p>Подобным образом можно определять и вызывать и другие функции. Например, определим и выполним несколько функций:</p>
                    <pre><code>
                        <p>def say_hello():</p>
                        <p>    print("Hello")</p>
                        <p> </p>
                        <p> </p>
                        <p>def say_goodbye():</p>
                        <p>    print("Good Bye")</p>
                        <p> </p>
                        <p> </p>
                        <p>say_hello()</p>
                        <p>say_goodbye()</p>
                    </code></pre>
                    <p>Консольный вывод:</p>
                    <p></p>
                    <p>Hello</p>
                    <p>Good Bye</p>
                    <p>Локальные функции</p>
                    <p>Одни функции могут определяться внутри других функций - внутренние функции еще называют локальными. Локальные функции можно использовать только внутри той функции, в которой они определены. Например:</p>
                    <pre><code>
                        <p>def print_messages():</p>
                        <p>    # определение локальных функций</p>
                        <p>    def say_hello(): print("Hello")</p>
                        <p>    def say_goodbye(): print("Good Bye")</p>
                        <p>    # вызов локальных функций</p>
                        <p>    say_hello()</p>
                        <p>    say_goodbye()</p>
                        <p> </p>
                        <p># Вызов функции print_messages</p>
                        <p>print_messages()</p>
                        <p> </p>
                        <p>#say_hello() # вне функции print_messages функция say_hello не доступна</p>
                    </code></pre>
                    <p>Здесь функции say_hello() и say_goodbye() определены внутри функции print_messages() и поэтому по отношению к ней являются локальными. Соответственно они могут использоваться только внутри функции print_messages()</p>
                    <p></p>
                    <p>Организация программы и функция main</p>
                    <p>В программе может быть определено множество функций. И чтобы всех их упорядочить, одним из способов их организации является добавление специальной функции (обычно называется main), в которой потом уже вызываются другие функции:</p>
                    <pre><code>
                        <p>def main():</p>
                        <p>    say_hello()</p>
                        <p>    say_goodbye()</p>
                        <p> </p>
                        <p>def say_hello():</p>
                        <p>    print("Hello")</p>
                        <p> </p>
                        <p>def say_goodbye():</p>
                        <p>    print("Good Bye")</p>
                        <p> </p>
                        <p># Вызов функции main</p>
                        <p>main()</p>
                    </code></pre>
                </div>
                <div id="them10">
                    <h4></h4>
                    <p>Функция может принимать параметры. Через параметры в функцию можно передавать данные. Банальный пример - функция print(), которая с помощью параметра принимает значение, выводимое на консоль.</p>
                    <p>Теперь определим и используем свою функцию с параметрами:</p>
                    <pre><code>
                        <p>def say_hello(name):</p>
                        <p>    print(f"Hello, {name}")</p>
                        <p> </p>
                        <p>say_hello("Tom")</p>
                        <p>say_hello("Bob")</p>
                        <p>say_hello("Alice")</p>
                    </code></pre>
                    <p>Функция say_hello имеет параметр name, и при вызове функции мы можем передать этому параметру какой-либо значение. Внутри функции мы можем использовать параметр как обычную переменную, например, вывести значение этого параметра на консоль функцией print. Так, в выражении:</p>
                    <pre><code>
                        <p>say_hello("Tom")</p>
                    </code></pre>
                    <p>Строка "Tom" будет передаваться параметру name. В итоге при выполнении программы мы получим следующий консольный вывод:</p>
                    <p>Hello, Tom</p>
                    <p>Hello, Bob</p>
                    <p>Hello, Alice</p>
                    <p>При вызове функции значения передаются параметрам по позиции. Например, определим и вызовем функцию с несколькими параметрами:</p>
                    <pre><code>
                        <p>def print_person(name, age):</p>
                        <p>    print(f"Name: {name}")</p>
                        <p>    print(f"Age: {age}")</p>
                        <p> </p>
                        <p> </p>
                        <p>print_person("Tom", 37)</p>
                    </code></pre>
                    <p>Здесь функция print_person принимает два параметра: name и age. При вызове функции:</p>
                    <pre><code><p>print_person("Tom", 37)</p></code></pre>
                    <p>Первое значение - "Tom" передается первому параметру, то есть параметру name. Второе значение - 37 передается второму параметру - age. И внутри функции значения параметров выводятся на консоль:</p>
                    <p>Name: Tom</p>
                    <p>Age: 37</p>
                    <p>Значения по умолчанию</p>
                    <p>Некоторые параметры функции мы можем сделать необязательными, указав для них значения по умолчанию при определении функции. Например:</p>
                    <pre><code>
                        <p>def say_hello(name="Tom"):</p>
                        <p>    print(f"Hello, {name}")</p>
                        <p> </p>
                        <p> </p>
                        <p>say_hello()         # здесь параметр name будет иметь значение "Tom"</p>
                        <p>say_hello("Bob")    # здесь name = "Bob"</p>
                    </code></pre>
                    <p>Здесь параметр name является необязательным. И если мы не передаем при вызове функции для него значение, то применяется значение по умолчанию, то есть строка "Tom". Консольный вывод данной программы:</p>
                    <p>Hello, Tom</p>
                    <p>Hello, Bob</p>
                    <p>Если функция имеет несколько параметров, то необязательные параметры должны идти после обязательных. Например:</p>
                    <pre><code>
                        <p>def print_person(name, age = 18):</p>
                        <p>    print(f"Name: {name}  Age: {age}")</p>
                        <p> </p>
                        <p> </p>
                        <p>print_person("Bob")</p>
                        <p>print_person("Tom", 37)</p>
                    </code></pre>
                    <p>Здесь параметр age является необязательным и по умолчанию имеет значение 18. Перед ним расположен обязательный параметр name. Поэтому при вызове функции мы можем не передавать значение параметру age, но параметру name передать значение необходимо.</p>
                    <p>При необходимости мы можем сделать все параметры необязательными:</p>
                    <pre><code>
                        <p>def print_person(name = "Tom", age = 18):</p>
                        <p>    print(f"Name: {name}  Age: {age}")</p>
                        <p> </p>
                        <p> </p>
                        <p>print_person()              # Name: Tom  Age: 18</p>
                        <p>print_person("Bob")         # Name: Bob  Age: 18</p>
                        <p>print_person("Sam", 37)     # Name: Sam  Age: 37</p>
                    </code></pre>
                    <p>Передача значений параметрам по имени. Именованные параметры</p>
                    <p>В примерах выше при вызове функции значения передаются параметрами функции по позиции. Но также можно передавать значения параметрам по имени. Для этого при вызове функции указывается имя параметра и ему присваивается значение:</p>
                    <pre><code>
                        <p>def print_person(name, age):</p>
                        <p>    print(f"Name: {name}  Age: {age}")</p>
                        <p> </p>
                        <p> </p>
                        <p>print_person(age = 22, name = "Tom")</p>
                    </code></pre>
                    <p>В данном случае значения параметрам age и name передаются по имени. И несмотря на то, что параметр name идет первым в определении функции, мы можем при вызове функции написать print_person(age = 22, name = "Tom") и таким образом передать число 22 параметру age, а строку "Tom" параметру name.</p>
                    <p>Символ * позволяет установить, какие параметры будут именнованными - то есть такие параметры, которым можно передать значения только по имени. Все параметры, которые располагаются справа от символа *, получают значения только по имени:</p>
                    <pre><code>
                        <p>def print_person(name, *,  age, company):</p>
                        <p>    print(f"Name: {name}  Age: {age}  Company: {company}")</p>
                        <p> </p>
                        <p> </p>
                        <p>print_person("Bob", age = 41, company ="Microsoft")    # Name: Bob  Age: 41  company: Microsoft</p>
                    </code></pre>
                    <p>В данном случае параметры age и company являются именнованными.</p>
                    <p></p>
                    <p>Можно сделать все параметры именнованными, поставив перед списком параметров символ *:</p>
                    <pre><code>
                        <p>def print_person(*,  name, age, company):</p>
                        <p>    print(f"Name: {name}  Age: {age}  Company: {company}")</p>
                    </code></pre>
                    <p>Если наоборот надо определить параметры, которым можно передавать значения только по позиции, то есть позиционные параметры, то можно использовать символ /: все параметры, которые идут до символа / , являются позиционными и могут получать значения только по позиции</p>
                    <pre><code>
                        <p>def print_person(name, /, age, company="Microsoft"):</p>
                        <p>    print(f"Name: {name}  Age: {age}  Company: {company}")</p>
                        <p> </p>
                        <p> </p>
                        <p>print_person("Tom", company="JetBrains", age = 24)     # Name: Tom  Age: 24  company: JetBrains</p>
                        <p>print_person("Bob", 41)                 # Name: Bob  Age: 41  company: Microsoft</p>
                    </code></pre>
                    <p>В данном случае параметр name является позиционным.</p>
                    <p></p>
                    <p>Для одной функции можно определять одновременно позиционные и именнованные параметры.</p>
                    <pre><code>
                        <p>def print_person(name, /,  age = 18, *, company):</p>
                        <p>    print(f"Name: {name}  Age: {age}  Company: {company}")</p>
                        <p> </p>
                        <p> </p>
                        <p>print_person("Sam", company ="Google")               # Name: Sam  Age: 18  company: Google</p>
                        <p>print_person("Tom", 37, company ="JetBrains")        # Name: Tom  Age: 37  company: JetBrains</p>
                        <p>print_person("Bob", company ="Microsoft", age = 42)  # Name: Bob  Age: 42  company: Microsoft</p>
                    </code></pre>
                    <p>В данном случае параметр name располагается слева от символа /, поэтому является позиционным и обязательным - ему можно передать значение только по позиции.</p>
                    <p>Параметр company является именнованным, так как располагается справа от символа *. Параметр age может получать значение по имени и по позиции.</p>
                    <p>Неопределенное количество параметров</p>
                    <p>С помощью символа звездочки можно определить параметр, через который можно передавать неопределенное количество значений. Это может быть полезно, когда мы хотим, чтобы функция получала несколько значений, но мы точно не знаем, сколько именно. Например, определим функцию подсчета суммы чисел:</p>
                    <pre><code>
                        <p>def sum(*numbers):</p>
                        <p>    result = 0</p>
                        <p>    for n in numbers:</p>
                        <p>        result += n</p>
                        <p>    print(f"sum = {result}")</p>
                        <p> </p>
                        <p> </p>
                        <p>sum(1, 2, 3, 4, 5)      # sum = 15</p>
                        <p>sum(3, 4, 5, 6)         # sum = 18</p>
                    </code></pre>
                    <p>В данном случае функция sum принимает один параметр - *numbers, но звездочка перед названием параметра указывает, что фактически на место этого параметра мы можем передать неопределенное количество значений или набор значений. В самой функции с помощью цикла for можно пройтись по этому набору, получить каждое значение из этого набора в переменную n и произвести с ним какие-нибудь действия. Например, в данном случае вычисляется сумма переданных чисел.</p>
                </div>
                <div id="them11">
                    <h4></h4>
                    <p>Функция может возвращать результат. Для этого в функции используется оператор return, после которого указывается возвращаемое значение:</p>
                    <p>def имя_функции ([параметры]):</p>
                    <p>    инструкции</p>
                    <p>    return возвращаемое_значение</p>
                    <p>Определим простейшую функцию, которая возвращает значение:</p>
                    <pre><code>
                        <p>def get_message():</p>
                        <p>    return "Hello METANIT.COM"</p>
                    </code></pre>
                    <p>Здесь после оператора return идет строка "Hello METANIT.COM" - это значение и будет возвращать функция get_message().</p>
                    <p>Затем это результат функции можно присвоить переменной или использовать как обычное значение:</p>
                    <pre><code>
                        <p>def get_message():</p>
                        <p>    return "Hello METANIT.COM"</p>
                        <p> </p>
                        <p> </p>
                        <p>message = get_message()  # получаем результат функции get_message в переменную message</p>
                        <p>print(message)          # Hello METANIT.COM</p>
                        <p> </p>
                        <p># можно напрямую передать результат функции get_message</p>
                        <p>print(get_message())    # Hello METANIT.COM</p>
                    </code></pre>
                    <p>После оператора return может идти и сложное вычислямое выражение, результат которого будет возвращаться из функции. Например, определим функцию, которая увеличивает число в два раза:</p>
                    <pre><code>
                        <p>def double(number):</p>
                        <p>    return 2 * number</p>
                    </code></pre>
                    <p>Здесь функция double будет возвращать результат выражения 2 * number:</p>
                    <pre><code>
                        <p>def double(number):</p>
                        <p>    return 2 * number</p>
                        <p> </p>
                        <p>result1 = double(4)     # result1 = 8</p>
                        <p>result2 = double(5)     # result2 = 10</p>
                        <p>print(f"result1 = {result1}")   # result1 = 8</p>
                        <p>print(f"result2 = {result2}")   # result2 = 10</p>
                    </code></pre>
                    <p>Или другой пример - получение суммы чисел:</p>
                    <pre><code>
                        <p>def sum(a, b):</p>
                        <p>    return a + b</p>
                        <p> </p>
                        <p> </p>
                        <p>result = sum(4, 6)                  # result = 0</p>
                        <p>print(f"sum(4, 6) = {result}")      # sum(4, 6) = 10</p>
                        <p>print(f"sum(3, 5) = {sum(3, 5)}")   # sum(3, 5) = 8</p>
                    </code></pre>
                    <p>Выход из функции</p>
                    <p>Оператор return не только возвращает значение, но и производит выход из функции. Поэтому он должен определяться после остальных инструкций. Например:</p>
                    <pre><code>
                        <p>def get_message():</p>
                        <p>    return "Hello METANIT.COM"</p>
                        <p>    print("End of the function")</p>
                        <p> </p>
                        <p>print(get_message())</p>
                    </code></pre>
                    <p>С точки зрения синтаксиса данная функция корректна, однако ее инструкция print("End of the function") не имеет смысла - она никогда не выполнится, так как до ее выполнения оператор return возвратит значение и произведет выход из функции.</p>
                    <p>Однако мы можем использовать оператор return и в таких функциях, которые не возвращают никакого значения. В этом случае после оператора return не ставится никакого возвращаемого значения. Типичная ситуация - в зависимости от опеределенных условий произвести выход из функции:</p>
                    <pre><code>
                        <p>def print_person(name, age):</p>
                        <p>    if age > 120 or age < 1:</p>
                        <p>        print("Invalid age")</p>
                        <p>        return</p>
                        <p>    print(f"Name: {name}  Age: {age}")</p>
                        <p> </p>
                        <p> </p>
                        <p>print_person("Tom", 22)</p>
                        <p>print_person("Bob", -102)</p>
                    </code></pre>
                    <p>Здесь функция print_person в качестве параметров принимает имя и возраст пользователя. Однако в функции вначале мы проверяем, соответствует ли возраст некоторому диапазону (меньше 120 и больше 0). Если возраст находится вне этого диапазона, то выводим сообщение о недопустимом возрасте и с помощью оператора return выходим из функции. После этого функция заканчивает свою работу.</p>
                    <p>Однако если возраст корректен, то выводим информацию о пользователе на консоль. Консольный вывод:</p>
                    <p></p>
                    <p>Name: Tom  Age: 22</p>
                    <p>Invalid age</p>
                </div>
                <div id="them12">
                    <h4></h4>
                    <p>Функция как тип</p>
                    <p>В Python функция фактически представляет отдельный тип. Так мы можем присвоить переменной какую-нибудь функцию и затем, используя переменную, вызывать данную функцию. Например:</p>
                    <pre><code>
                        <p>def say_hello(): print("Hello")</p>
                        <p>def say_goodbye(): print("Good Bye")</p>
                        <p> </p>
                        <p>message = say_hello</p>
                        <p>message()       # Hello</p>
                        <p>message = say_goodbye</p>
                        <p>message()       # Good Bye</p>
                    </code></pre>
                    <p>В данном случае переменной message присваивается одна из функций. Сначала ей передается функция say_hello():</p>
                    <pre><code>
                        <p>message = say_hello</p>
                    </code></pre>
                    <p>После этого переменная message будет указывать на данную функцию, то есть фактически представлять функцию say_hello. А это значит, что мы можем вызывать переменную message как обычную функцию:</p>
                    <pre><code>
                        <p>message()       # Hello</p>
                    </code></pre>
                    <p>Фактически это приведет к выполнению функции say_hello, и на консоль будет выведена строка "Hello". Затем подобным образом мы можем передать переменной message другую функцию и вызвать ее.</p>
                    <p>Подобным образом можно через переменную вызывать функцию с параметрами и возвращать ее результат:</p>
                    <pre><code>
                        <p>def sum(a, b): return a + b</p>
                        <p>def multiply(a, b): return a * b</p>
                        <p> </p>
                        <p>operation = sum</p>
                        <p>result = operation(5, 6)</p>
                        <p>print(result)   # 11</p>
                        <p> </p>
                        <p>operation = multiply</p>
                        <p>print(operation(5, 6))      # 30</p>
                    </code></pre>
                    <p>Функция как параметр функции</p>
                    <p>Поскольку функция в Python может представлять такое же значение как строка или число, соответственно мы можем передать ее в качестве параметра в другую функцию. Например, определим функцию, которая выводит на консоль результат некоторой операции:</p>
                    <pre><code>
                        <p>def do_operation(a, b, operation):</p>
                        <p>    result = operation(a, b)</p>
                        <p>    print(f"result = {result}")</p>
                        <p> </p>
                        <p>def sum(a, b): return a + b</p>
                        <p>def multiply(a, b): return a * b</p>
                        <p> </p>
                        <p>do_operation(5, 4, sum)         # result = 9</p>
                        <p>do_operation(5, 4, multiply)   # result = 20</p>
                    </code></pre>
                    <p>В данном случае функция do_operation имеет три параметра, причем третий параметр, как предполагается, будет представлять функцию, которая принимает два параметра и возвращает некоторый результат. Иными словами третий параметр - operation представляет некоторую операцию, но на момент определения функции do_operation мы точно не знаем, что это будет за операция. Мы только знаем, что она принимает два параметр и возвращает какой-то результат, который потом выводится на консоль.</p>
                    <p>При вызове функции do_operation мы сможем передать в качестве третьего параметра другую функцию, например, функцию sum:</p>
                    <pre><code>
                        <p>do_operation(5, 4, sum)</p>
                    </code></pre>
                    <p>То есть в данном случае параметр operation фактически будет представлять функцию sum и будет возвращать сумму дву чисел.</p>
                    <p>Затем аналогичным образов в вызов функции do_operation можно передать третьему параметру другую функцию - multiply, которая выполнит умножение чисел:</p>
                    <pre><code>
                        <p>do_operation(5, 4, multiply)   # result = 20</p>
                    </code></pre>
                    <p>Таким образом, более гибкие по функциональности функции, которые через параметры принимают другие функции.</p>
                    <p>Функция как результат функции</p>
                    <p>Также одна функция в Python может возвращать другую функцию. Например, определим функцию, которая в зависимости от значения параметра возвращает ту или иную операцию:</p>
                    <pre><code>
                        <p>def sum(a, b): return a + b</p>
                        <p>def subtract(a, b): return a - b</p>
                        <p>def multiply(a, b): return a * b</p>
                        <p> </p>
                        <p> </p>
                        <p>def select_operation(choice):</p>
                        <p>    if choice == 1:</p>
                        <p>        return sum</p>
                        <p>    elif choice == 2:</p>
                        <p>        return subtract</p>
                        <p>    else:</p>
                        <p>        return multiply</p>
                        <p> </p>
                        <p> </p>
                        <p>operation = select_operation(1)     # operation = sum</p>
                        <p>print(operation(10, 6))             # 16</p>
                        <p> </p>
                        <p>operation = select_operation(2)     # operation = subtract</p>
                        <p>print(operation(10, 6))             # 4</p>
                        <p> </p>
                        <p>operation = select_operation(3)     # operation = multiply</p>
                        <p>print(operation(10, 6))             # 60</p>
                    </code></pre>
                    <p>В данном случае функция select_operation в зависимости от значения параметра choice возвращает одну из трех функций - sum, subtract и multiply. Затем мы мы можем получить результат функции select_operation в переменную operation:</p>
                    <pre><code>
                        <p>operation = select_operation(1)</p>
                    </code></pre>
                    <p>Так, в данном случае в функцию select_operation передается число 1, соответственно она будет возвращать функцию sum. Поэтому переменная operation фактически будет указывать на функцию sum, которая выполняет сложение двух чисел:</p>
                    <pre><code>
                        <p>print(operation(10, 6))             # 16 - фактически равно sum(10, 6)</p>
                    </code></pre>
                    <p>Аналогичным образом можно получить и выполнить другие функции.</p>
                </div>
                <div id="them13">
                    <h4></h4>
                    <p>Лямбда-выражения в языке Python представляют небольшие анонимные функции, которые определяются с помощью оператора lambda. Формальное определение лямбда-выражения:</p>
                    <p>lambda [параметры] : инструкция</p>
                    <p>Определим простейшее лямбда-выражение:</p>
                    <pre><code>
                        <p>message = lambda: print("hello")</p>
                        <p> </p>
                        <p>message()   # hello</p>
                    </code></pre>
                    <p>Здесь лямбда-выражение присваивается переменной message. Это лямбда-выражение не имеет параметров, ничего не возвращает и просто выводит строку "hello" на консоль. И через переменную message мы можем вызвать это лямбда-выражение как обычную функцию. Фактически оно аналогично следующей функции:</p>
                    <pre><code>
                        <p>def message(): </p>
                        <p>    print("hello")</p>
                    </code></pre>
                    <p>Если лямбда-выражение имеет параметры, то они определяются после ключевого слова lambda. Если лямбда-выражение возвращает какой-то результат, то он указывается после двоеточия. Например, определим лямбда-выражение, которое возвращает квадрат числа:</p>
                    <pre><code>
                        <p>square = lambda n: n * n</p>
                        <p> </p>
                        <p>print(square(4))    # 16</p>
                        <p>print(square(5))    # 25</p>
                    </code></pre>
                    <p>В данном случае лямбда-выражение принимает один параметр - n. Справа от двоеточия идет возвращаемое значение - n* n. Это лямбда-выражение аналогично следующей функции:</p>
                    <pre><code>
                        <p>def square2(n): return n * n</p>
                    </code></pre>
                    <p>Аналогичным образом можно создавать лямбда-выражения, которые принимают несколько параметров:</p>
                    <pre><code>
                        <p>sum = lambda a, b: a + b</p>
                        <p> </p>
                        <p>print(sum(4, 5))    # 9</p>
                        <p>print(sum(5, 6))    # 11</p>
                    </code></pre>
                    <p>Хотя лямбда-выражения позволяют немного сократить определения функций, тем не менее они ограничены тем, что они могут выполнять только одно выражение. Однако они могут быть довольно удобны в тех случаях, когда необходимо использовать функцию для передачи в качестве параметра или возвращения в другой функции. Например, передача лямбда-выражения в качестве параметра:</p>
                    <pre><code>
                        <p>def do_operation(a, b, operation):</p>
                        <p>    result = operation(a, b)</p>
                        <p>    print(f"result = {result}")</p>
                        <p> </p>
                        <p>do_operation(5, 4, lambda a, b: a + b)  # result = 9</p>
                        <p>do_operation(5, 4, lambda a, b: a * b)  # result = 20</p>
                    </code></pre>
                    <p>В данном случае нам нет необходимости определять функции, чтобы передать их в качестве параметра, как в прошлой статье.</p>
                    <p>То же самое касается и возвращение лямбда-выражений из функций:</p>
                    <pre><code>
                        <p>def select_operation(choice):</p>
                        <p>    if choice == 1:</p>
                        <p>        return lambda a, b: a + b</p>
                        <p>    elif choice == 2:</p>
                        <p>        return lambda a, b: a - b</p>
                        <p>    else:</p>
                        <p>        return lambda a, b: a * b</p>
                        <p> </p>
                        <p> </p>
                        <p>operation = select_operation(1)  # operation = sum</p>
                        <p>print(operation(10, 6))  # 16</p>
                        <p> </p>
                        <p>operation = select_operation(2)  # operation = subtract</p>
                        <p>print(operation(10, 6))  # 4</p>
                        <p> </p>
                        <p>operation = select_operation(3)  # operation = multiply</p>
                        <p>print(operation(10, 6))  # 60</p>
                    </code></pre>
                </div>
                <div id="them14">
                    <h4></h4>
                    <p>В операциях с данными могут применяться значения различных типов. Например, складываются число типа int и число типа float:</p>
                    <pre><code>
                        <p>a = 2       # число int</p>
                        <p>b = 2.5     # число float</p>
                        <p>c = a + b</p>
                        <p>print(c)    # 4.5</p>
                    </code></pre>
                    <p>В данном случае никакой ошибки не будет. Однако Python не всегда может автоматически производить операции, в которых участвуют данные разных типов. Рассмотрим, какие в данном случае действуют правила.</p>
                    <p>Неявные преобразования</p>
                    <p>Оба числа в арифметических операциях должны представлять один и тот же тип. Если же два операнда операции представляют разные типы данных, то Python пытается автоматически выполнить преобразования к одному из типов в соответствии со следующми правилами:</p>
                    <p>Если один из операндов операции представляет комплексное число (тип complex), то другой операнд также преобразуется к типу complex.</p>
                    <p>Иначе, если один из операндов представляет тип float, то второй операнд также преобразуется к типу float. Собственно так и произошло в примере выше, где значение переменной a было преобразовано в тип float</p>
                    <p>Иначе, оба операнда должны представлять тип int, и в этом случае преобазование не требуется</p>
                    <p>Явные преобразования</p>
                    <p>Но в некоторых случаях возникает необходимость вручную выполнить преобразование типов. Например, пусть у нас будет следующий код:</p>
                    <pre><code>
                        <p>a = "2"</p>
                        <p>b = 3</p>
                        <p>c = a + b</p>
                    </code></pre>
                    <p>Мы ожидаем, что "2" + 3 будет равно 5. Однако этот код сгенерирует исключение, так как первое число на самом деле представляет строку. И мы увидим при выполнении кода что-то наподобие:</p>
                    <pre><code>
                        <p>Traceback (most recent call last):</p>
                        <p>  File "/Users/eugene/PycharmProjects/HelloApp/main.py", line 3, in </p>
                        <p>    c = a + b</p>
                        <p>TypeError: can only concatenate str (not "int") to str</p>
                    </code></pre>
                    <p>Для преобразования типов Python предоставляет ряд встроенных функций:</p>
                    <p>int(): преобразует значение в целое число</p>
                    <p>float(): преобразует значение в число с плавающей точкой</p>
                    <p>str(): преобразует значение в строку</p>
                    <p>int</p>
                    <p>Так, в предыдущем примере преобазуем строку в число с помощью функции int():</p>
                    <pre><code>
                        <p>a = "2"</p>
                        <p>b = 3</p>
                        <p>c = int(a) + b</p>
                        <p>print(c)    # 5</p>
                    </code></pre>
                    <p>Примеры преобразований с помощью int():</p>
                    <pre><code>
                        <p>a = int(15)     # a = 15</p>
                        <p>b = int(3.7)    # b = 3</p>
                        <p>c = int("4")    # c = 4</p>
                        <p>e = int(False)    # e = 0</p>
                        <p>f = int(True)     # f = 1</p>
                    </code></pre>
                    <p>Однако если значение не может быть преобразовано, то функция int выдаст ошибку ValueError: invalid literal for int() with base 10:</p>
                    <pre><code>
                        <p>b = int("a1c")    # Ошибка</p>
                        <p>c = int("4.7")    # Ошибка</p>
                    </code></pre>
                    <p>float</p>
                    <p>Аналогичным образом действует функция float(), которая преобразует в число с плавающей точкой.</p>
                    <pre><code>
                        <p>a = "2.7"</p>
                        <p>b = 3</p>
                        <p>c = float(a) + b</p>
                        <p>print(c) # 5.7</p>
                    </code></pre>
                    <p>Примеры преобразований с помощью float():</p>
                    <pre><code>
                        <p>a = float(15)       # a = 15.0</p>
                        <p>b = float(3.7)      # b = 3.7</p>
                        <p>c = float("4.7")    # c = 4.7</p>
                        <p>d = float("5")      # d = 5.0</p>
                        <p>e = float(False)    # e = 0.0</p>
                        <p>f = float(True)     # f = 1.0</p>
                    </code></pre>
                    <p>Но опять же не все значения могут автоматически преобразованы в float. Так, в следующем случае Python сгенерирует ошибку:</p>
                    <pre><code>
                        <p>d = float("abc")  # Ошибка</p>
                    </code></pre>
                    <p>str</p>
                    <p>Функция str() преобразует значение в строку:</p>
                    <pre><code>
                        <p>a = str(False)      # a = "False"</p>
                        <p>b = str(True)       # b = "True"</p>
                        <p>c = str(5)         # c = "5"</p>
                        <p>d = str(5.7)       # d = "5.7"</p>
                    </code></pre>
                    <p>Функция str() может быть актуальна, например, при добавлении к строке значения другого типа. Например, в следующем случае мы получим ошибку:</p>
                    <pre><code>
                        <p>age = 22</p>
                        <p>message = "Age: " + age     # Ошибка</p>
                        <p>print(message)</p>
                    </code></pre>
                    <p>Если число складывается с число, то это стандартная операция сложения чисел. Если строка складывается со строкой, то это операция объединения строк. Но каким образом выполнить операцию сложения по отношение к строке и числу, Python не знает. И если мы в данном случае мы хотим выполнить операцию объединения строк, то число можно привести к строке с помощью функции str():</p>
                    <pre><code>
                        <p>age = 22</p>
                        <p>message = "Age: " + str(age)   # Age: 22</p>
                        <p>print(message)</p>
                    </code></pre>
                </div>
                <div id="them15">
                    <h4></h4>
                    <p>Область видимости или scope определяет контекст переменной, в рамках которого ее можно использовать. В Python есть два типа контекста: глобальный и локальный.</p>
                    <p>Глобальный контекст</p>
                    <p>Глобальный контекст подразумевает, что переменная является глобальной, она определена вне любой из функций и доступна любой функции в программе. Например:</p>
                    <pre><code>
                        <p>name = "Tom"</p>
                        <p> </p>
                        <p> </p>
                        <p>def say_hi():</p>
                        <p>    print("Hello", name)</p>
                        <p> </p>
                        <p> </p>
                        <p>def say_bye():</p>
                        <p>    print("Good bye", name)</p>
                        <p> </p>
                        <p>say_hi()</p>
                        <p>say_bye()</p>
                    </code></pre>
                    <p>Здесь переменная name является глобальной и имеет глобальную область видимости. И обе определенные здесь функции могут свободно ее использовать.</p>
                    <p>Локальный контекст</p>
                    <p>В отличие от глобальных переменных локальная переменная определяется внутри функции и доступна только из этой функции, то есть имеет локальную область видимости:</p>
                    <pre><code>
                        <p>def say_hi():</p>
                        <p>    name = "Sam"</p>
                        <p>    surname = "Johnson"</p>
                        <p>    print("Hello", name, surname)</p>
                        <p> </p>
                        <p> </p>
                        <p>def say_bye():</p>
                        <p>    name = "Tom"</p>
                        <p>    print("Good bye", name)</p>
                        <p> </p>
                        <p>say_hi()</p>
                        <p>say_bye()</p>
                    </code></pre>
                    <p>В данном случае в каждой из двух функций определяется локальная переменная name. И хотя эти переменные называются одинаково, но тем не менее это две разных переменных, каждая из которых доступна только в рамках своей функции. Также в функции say_hi() определена переменная surname, которая также является локальной, поэтому в функции say_bye() мы ее использовать не сможем.</p>
                    <p>Скрытие переменных</p>
                    <p>Есть еще один вариант определения переменной, когда локальная переменная скрывают глобальную с тем же именем:</p>
                    <pre><code>
                        <p>name = "Tom"</p>
                        <p> </p>
                        <p> </p>
                        <p>def say_hi():</p>
                        <p>    name = "Bob"        # скрываем значение глобальной переменной</p>
                        <p>    print("Hello", name)</p>
                        <p> </p>
                        <p> </p>
                        <p>def say_bye():</p>
                        <p>    print("Good bye", name)</p>
                        <p> </p>
                        <p> </p>
                        <p>say_hi()    # Hello Bob</p>
                        <p>say_bye()   # Good bye Tom</p>
                    </code></pre>
                    <p>Здесь определена глобальная переменная name. Однако в функции say_hi определена локальная переменная с тем же именем name. И если функция say_bye использует глобальную переменную, то функция say_hi использует локальную переменную, которая скрывает глобальную.</p>
                    <p></p>
                    <p>Если же мы хотим изменить в локальной функции глобальную переменную, а не определить локальную, то необходимо использовать ключевое слово global:</p>
                    <pre><code>
                        <p>name = "Tom"</p>
                        <p> </p>
                        <p> </p>
                        <p>def say_hi():</p>
                        <p>    global  name</p>
                        <p>    name = "Bob"        # изменяем значение глобальной переменной</p>
                        <p>    print("Hello", name)</p>
                        <p> </p>
                        <p> </p>
                        <p>def say_bye():</p>
                        <p>    print("Good bye", name)</p>
                        <p> </p>
                        <p> </p>
                        <p>say_hi()    # Hello Bob</p>
                        <p>say_bye()   # Good bye Bob</p>
                    </code></pre>
                    <p>nonlocal</p>
                    <p>Выражение nonlocal прикрепляет идентификатор к переменной из ближайщего окружающего контекста (за исключением глобального контекста). Обычно nonlocal применяется во вложенных функциях, когда надо прикрепить идентификатор за переменной или параметром окружающей внешней функции. Рассмотрим ситуацию, где это выражение может пригодиться:</p>
                    <pre><code>
                        <p>def outer():  # внешняя функция</p>
                        <p>    n = 5</p>
                        <p> </p>
                        <p>    def inner():    # вложенная функция</p>
                        <p>        print(n)</p>
                        <p> </p>
                        <p>    inner()     # 5</p>
                        <p>    print(n)</p>
                        <p> </p>
                        <p> </p>
                        <p>outer()     # 5</p>
                    </code></pre>
                    <p>Здесь вложенная локальная функция inner() выводит на консоль значение переменной n, которая определена во внешней функции outer(). Затем в функции outer() вызывается внутренняя функция inner().</p>
                    <p>При вызове функции outer() здесь мы ожидаемо увидим на консоли два раза число 5. Однако в данном случае вложенная функция inner() просто получает значение. Теперь возьмем другую ситуацию, когда вложенная функция присваивает значение переменной:</p>
                    <pre><code>
                        <p>def outer():  # внешняя функция</p>
                        <p>    n = 5</p>
                        <p> </p>
                        <p>    def inner():    # вложенная функция</p>
                        <p>        n = 25</p>
                        <p>        print(n)</p>
                        <p> </p>
                        <p>    inner()     # 25</p>
                        <p>    print(n)</p>
                        <p> </p>
                        <p> </p>
                        <p>outer()     # 5 </p>
                        <p># 25    - inner</p>
                        <p># 5     - outer</p>
                    </code></pre>
                    <p>При присвоении значения во вложенной функции: n = 25 будет создаваться новая переменная n, которая скроет переменную n из окружающей внешней функции outer. В итоге мы получим при выводе два разных числа. Чтобы во вложенной функции указать, что идентификатор во вложенной функции будет представлять переменную из окружающей функции, применяется выражение nonlocal:</p>
                    <pre><code>
                        <p>def outer():  # внешняя функция</p>
                        <p>    n = 5</p>
                        <p> </p>
                        <p>    def inner():    # вложенная функция</p>
                        <p>        nonlocal n  # указываем, что n - это переменная из окружающей функции</p>
                        <p>        n = 25</p>
                        <p>        print(n)</p>
                        <p> </p>
                        <p>    inner()     # 25</p>
                        <p>    print(n)</p>
                        <p> </p>
                        <p> </p>
                        <p>outer()          # 25</p>
                    </code></pre>
                </div>
                <div id="them16">
                    <h4></h4>
                    <p>Замыкание (closure) представляет функцию, которая запоминает свое лексическое окружение даже в том случае, когда она выполняется вне своей области видимости.</p>
                    <p>Технически замыкание включает три компонента:</p>
                    <p>внешняя функция, которая определяет некоторую область видимости и в которой определены некоторые переменные и параметры - лексическое окружение</p>
                    <p>переменные и параметры (лексическое окружение), которые определены во внешней функции</p>
                    <p>вложенная функция, которая использует переменные и параметры внешней функции</p>
                    <p>Для определения замыканий в Python применяются локальные функции:</p>
                    <pre><code>
                        <p>def outer():        # внешняя функция</p>
                        <p>    n = 5           # лексическое окружение - локальная переменная</p>
                        <p> </p>
                        <p>    def inner():      # локальная функция</p>
                        <p>        nonlocal n</p>
                        <p>        n += 1        # операции с лексическим окружением</p>
                        <p>        print(n)</p>
                        <p> </p>
                        <p>    return inner</p>
                        <p> </p>
                        <p> </p>
                        <p>fn = outer()   # fn = inner, так как функция outer возвращает функцию inner</p>
                        <p># вызываем внутреннюю функцию inner</p>
                        <p>fn()    # 6</p>
                        <p>fn()    # 7</p>
                        <p>fn()    # 8</p>
                    </code></pre>
                    <p>Здесь функция outer определяет локальную переменную n - это и есть лексическое окружение для внутренней функции:</p>
                    <p></p>
                    <p>Внутри функции outer определена внутренняя функция - локальная функция inner, которая обращается к своему лексическому окружению - переменной n - увеличивает ее значение на единицу и выводит на консоль:</p>
                    <pre><code>
                        <p>def inner():      # локальная функция</p>
                        <p>    nonlocal n</p>
                        <p>    n += 1        # операции с лексическим окружением</p>
                        <p>    print(n)</p>
                    </code></pre>
                    <p>Эта локальная функция возвращается функцией outer:</p>
                    <pre><code>
                        <p>return inner</p>
                    </code></pre>
                    <p>В программе вызываем функцию outer и получаем в переменную fn локальную функцию inner:</p>
                    <pre><code>
                        <p>fn = outer()</p>
                    </code></pre>
                    <p>Переменная fn и представляет собой замыкание, то есть объединяет две вещи: функцию и окружение, в котором функция была создана. И несмотря на то, что мы получили локальную функцию и можем ее вызывать вне ее окружающей функции, в которой она определена, тем не менее она запомнила свое лексическое окружение и может к нему обращаться и изменять, что мы увидим по консольному выводу:</p>
                    <pre><code>
                        <p>fn()    # 6</p>
                        <p>fn()    # 7</p>
                        <p>fn()    # 8</p>
                    </code></pre>
                    <p>Применение параметров</p>
                    <p>Кроме внешних переменных к лексическому окружению также относятся параметры окружающей функции. Рассмотрим использование параметров:</p>
                    <pre><code>
                        <p>def multiply(n):</p>
                        <p>    def inner(m): return n * m</p>
                        <p> </p>
                        <p>    return inner</p>
                        <p> </p>
                        <p> </p>
                        <p>fn = multiply(5)</p>
                        <p>print(fn(5))        # 25</p>
                        <p>print(fn(6))        # 30</p>
                        <p>print(fn(7))        # 35</p>
                    </code></pre>
                    <p>Здесь внешняя функция - multiply возвращает функцию, которая принимает число и возвращает число.</p>
                    <p>Вызов функции multiply() возвращает локальную функцию inner:</p>
                    <pre><code>
                        <p>def inner(m): return n * m</p>
                    </code></pre>
                    <p>Эта функция запоминает окружение, в котором она была создана, в частности, значение параметра n. Кроме того, сама принимает параметр и возвращает произведение параметров n и m.</p>
                    <p>В итоге при вызове функции multiply определяется переменная fn, которая получает локальную функцию inner и ее лексическое окружение - значение параметра n:</p>
                    <pre><code>
                        <p>fn = multiply(5)</p>
                    </code></pre>
                    <p>В данном случае параметр n равен 5.</p>
                    <p>При вызове локальной функции, например, в случае:</p>
                    <pre><code>
                        <p>print(fn(6))        # 30</p>
                    </code></pre>
                    <p>Число 6 передается для параметра m локальной функции, которая возвращает произведение n и m, то есть 5 * 6 = 30.</p>
                    <p>Также можно было бы сократить этот код с помощью лямбд:</p>
                    <pre><code>
                        <p>def multiply(n): return lambda m: n * m</p>
                        <p> </p>
                        <p> </p>
                        <p>fn = multiply(5)</p>
                        <p>print(fn(5))        # 25</p>
                        <p>print(fn(6))        # 30</p>
                        <p>print(fn(7))        # 35</p>
                    </code></pre>
                </div>
                <div id="them17">
                    <h4></h4>
                    <p>Декораторы в Python представляют функцию, которая в качестве параметра получает функцию и в качестве результата также возвращает функцию. Декораторы позволяют модифицировать выполняемую функцию, значения ее параметров и ее результат без изменения исходного кода этой функции.</p>
                    <p>Рассмотрим простейший пример:</p>
                    <img src="" alt="">
                    <p>Вначале определяется собственно функция декоратора, которая в данном случае называется select(). В качестве параметра декоратор получает функцию (в данном случае параметр input_func), к которой этот декоратор будет применяться:</p>
                    <img src="" alt="">
                    <p>Результатом декоратора в данном случае является локальная функция output_func, в которой вызывается входная функция input_func. Для простоты здесь перед и после вызыва input_func для красоты просто выводим набор символов "*".</p>
                    <p>Далее определяется стандартная функция, к которой применяется декоратор - в данном случае это функция hello, которая просто выводит на консоль некоторую строку:</p>
                    <img src="" alt="">
                    <p>Для применения декоратора перед определением функции указывается символ @, после которого идет имя декоратора. То есть в данном случае к функции hello() применяется декоратор select().</p>
                    <p>Далее вызываем обычную функцию:</p>
                    <p>hello()</p>
                    <p>Поскольку к этой функции применяется декоратор select, то в результате функциия hello передается в декоратор select() в качестве параметра input_func. И поскольку декоратор возвращает новую функцию - output_func, то фактически в данном случае будет выполняться именно эта функция output_func()</p>
                    <p></p>
                    <p>В итоге мы получим следующий консольный вывод:</p>
                    <img src="" alt="">
                    <p>Получение параметров функции в декораторе</p>
                    <p>Декоратор может перехватывать передаваемые в функцию аргументы:</p>
                    <img src="" alt="">
                    <p>Здесь функция print_person() принимает два параметра: name (имя) и age (возраст). К этой функции применяется декоратор check()</p>
                    <p>В декораторе check возвращается локальная функция output_func(), которая принимает некоторый набор значений в виде параметра *args - это те значения, которые передаются в оригинальную функцию, к которой применяется декоратор. То есть в данном случае *args будет содержать значения параметров name и age.</p>
                    <img src="" alt="">
                    <p>Здесь просто передаем эти значения в оригинальную функцию:</p>
                    <p>input_func(*args)</p>
                    <p>В итоге в данном получим следующий консольный вывод</p>
                    <img src="" alt="">
                    <p>Но что, если в функцию print_person будет передано какое-то недопустимое значение, например, отрицательный возраст? Одним из преимуществ декораторов как раз является то, что мы можем проверить и при необходимости модифицировать значения параметров. Например:</p>
                    <img src="" alt="">
                    <p>args фактически представляет набор значений, и, используя индексы, мы можем получить значения параметров по позиции и что-то с ними сделать. Так, здесь, если значение возраста меньше 0, то устанавливаем 1. Затем передаем эти значения в вызов функции. В итоге здесь получим следующий вывод:</p>
                    <img src="" alt="">
                    <p>Получение результата функции</p>
                    <p>Подобным образом можно получить результат функции и при необходимости изменить его:</p>
                    <img src="" alt="">
                    <p>Здесь определена функция sum(), которая возвращает сумму чисел. В декораторе check проверяем результат функции и для простоты, если он меньше нуля, то возвращаем 0.</p>
                    <p>Консольный вывод программы:</p>
                    <img src="" alt="">
                </div>
            </div>
        </div>
    </div>
    <script src="../../js/bootstrap.bundle.min.js"></script>
</body>

</html>
