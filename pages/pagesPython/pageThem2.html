<!DOCTYPE html>
<html lang="ru">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="../../css/bootstrap.min.css">
    <link rel="stylesheet" href="../../css/style.css">
    <title>CodeUser</title>
</head>

<body>
    <!-- Навигация -->
    <nav class="navbar navbar-expand-lg bg-body-tertiary">
        <div class="container-fluid">
            <a class="navbar-brand" href="#">Navbar</a>
            <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarNavDropdown"
                aria-controls="navbarNavDropdown" aria-expanded="false" aria-label="Toggle navigation">
                <span class="navbar-toggler-icon"></span>
            </button>
            <div class="collapse navbar-collapse" id="navbarNavDropdown">
                <ul class="navbar-nav">
                    <li class="nav-item">
                        <a class="nav-link active" aria-current="page" href="../../index.html">Главная</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link" href="#">Q&A</a>
                    </li>
                    <li class="nav-item dropdown">
                        <a class="nav-link dropdown-toggle" href="#" role="button" data-bs-toggle="dropdown"
                            aria-expanded="false">
                            Языки
                        </a>
                        <ul class="dropdown-menu">
                            <li><a class="dropdown-item" href="../pagesPython/mainPage.html">Python</a></li>
                            <!-- <li><a class="dropdown-item" href="../pagesJavaScript/mianPage.html">JavaScript</a></li> -->
                            <!-- <li><a class="dropdown-item" href="../pagesCSharp/">C#</a></li> -->
                            <!-- <li><a class="dropdown-item" href="../pagesPHP/mainPage.html">PHP</a></li> -->
                            <!-- <li><a class="dropdown-item" href="../pagesJava/mainPage.html">Java</a></li> -->
                        </ul>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link" href="#">Войти</a>
                    </li>
                </ul>
            </div>
        </div>
    </nav>
    <!--  -->
    <div class="container">
        <div class="row">
            <div class="col-xl-3">
                <div class="accordion accordion-flush" id="accordionFlushExample">
                    <div class="card" style="width: 18rem;">
                        <div class="card-body">
                          <h5 class="card-title">Глава 1. Введение в Python</h5>
                          <p class="card-text">Язык программирования Python. Установка Python и первая программа на Windows</p>
                        </div>
                      </div>
                    <div class="card" style="width: 18rem;">
                        <div class="card-body">
                            <h5 class="card-title">Глава 2. Основы Python</h5>
                            <div class="accordion-item">
                                <h6 class="accordion-header">
                                    <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse"
                                        data-bs-target="#flush-collapse1" aria-expanded="false"
                                        aria-controls="flush-collapse1">
                                        Темы раздела
                                    </button>
                                </h6>
                                <div id="flush-collapse1" class="accordion-collapse collapse"
                                    data-bs-parent="#accordionFlushExample">
                                    <div class="accordion-body">
                                        <ul class="list-group">
                                            <li class="list-group-item"><a class="link-offset-2 link-underline link-underline-opacity-0" href="pageThem1.html#them1">Введение в написание программ</a></li>
                                            <li class="list-group-item"><a class="link-offset-2 link-underline link-underline-opacity-0" href="pageThem1.html#them2">Переменные и типы данных</a></li>
                                            <li class="list-group-item"><a class="link-offset-2 link-underline link-underline-opacity-0" href="pageThem1.html#them3">Консольный ввод и вывод</a></li>
                                            <li class="list-group-item"><a class="link-offset-2 link-underline link-underline-opacity-0" href="pageThem1.html#them4">Арифметические операции с числами</a></li>
                                            <li class="list-group-item"><a class="link-offset-2 link-underline link-underline-opacity-0" href="pageThem1.html#them5">Поразрядные операции с числами</a></li>
                                            <li class="list-group-item"><a class="link-offset-2 link-underline link-underline-opacity-0" href="pageThem1.html#them6">Условные выражения</a></li>
                                            <li class="list-group-item"><a class="link-offset-2 link-underline link-underline-opacity-0" href="pageThem1.html#them7">Условная конструкция if</a></li>
                                            <li class="list-group-item"><a class="link-offset-2 link-underline link-underline-opacity-0" href="pageThem1.html#them8">Циклы</a></li>
                                            <li class="list-group-item"><a class="link-offset-2 link-underline link-underline-opacity-0" href="pageThem1.html#them9">Функции</a></li>
                                            <li class="list-group-item"><a class="link-offset-2 link-underline link-underline-opacity-0" href="pageThem1.html#them10">Параметры функции</a></li>
                                            <li class="list-group-item"><a class="link-offset-2 link-underline link-underline-opacity-0" href="pageThem1.html#them11">Оператор return и возвращение результата из функции</a></li>
                                            <li class="list-group-item"><a class="link-offset-2 link-underline link-underline-opacity-0" href="pageThem1.html#them12">Функция как тип, параметр и результат другой функции</a></li>
                                            <li class="list-group-item"><a class="link-offset-2 link-underline link-underline-opacity-0" href="pageThem1.html#them13">Лямбда-выражения</a></li>
                                            <li class="list-group-item"><a class="link-offset-2 link-underline link-underline-opacity-0" href="pageThem1.html#them14">Преобразование типов</a></li>
                                            <li class="list-group-item"><a class="link-offset-2 link-underline link-underline-opacity-0" href="pageThem1.html#them15">Область видимости переменных</a></li>
                                            <li class="list-group-item"><a class="link-offset-2 link-underline link-underline-opacity-0" href="pageThem1.html#them16">Замыкания</a></li>
                                            <li class="list-group-item"><a class="link-offset-2 link-underline link-underline-opacity-0" href="pageThem1.html#them17">Декораторы</a></li>
                                        </ul>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                    <div class="card" style="width: 18rem;">
                        <div class="card-body">
                            <h5 class="card-title">Глава 3. Объектно-ориентированное программирование</h5>
                            <div class="accordion-item">
                                <h6 class="accordion-header">
                                    <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse"
                                        data-bs-target="#flush-collapse2" aria-expanded="false"
                                        aria-controls="flush-collapse2">
                                        Темы раздела
                                    </button>
                                </h6>
                                <div id="flush-collapse2" class="accordion-collapse collapse"
                                    data-bs-parent="#accordionFlushExample">
                                    <div class="accordion-body">
                                        <ul class="list-group">
                                            <li class="list-group-item"><a class="link-offset-2 link-underline link-underline-opacity-0" href="#them1">Классы и объекты</a></li>
                                            <li class="list-group-item"><a class="link-offset-2 link-underline link-underline-opacity-0" href="#them2">Инкапсуляция, атрибуты и свойства</a></li>
                                            <li class="list-group-item"><a class="link-offset-2 link-underline link-underline-opacity-0" href="#them3">Наследование</a></li>
                                            <li class="list-group-item"><a class="link-offset-2 link-underline link-underline-opacity-0" href="#them4">Переопределение функционала базового класса</a></li>
                                            <li class="list-group-item"><a class="link-offset-2 link-underline link-underline-opacity-0" href="#them5">Атрибуты классов и статические методы</a></li>
                                            <li class="list-group-item"><a class="link-offset-2 link-underline link-underline-opacity-0" href="#them6">Класс object. Строковое представление объекта</a></li>
                                            <li class="list-group-item"><a class="link-offset-2 link-underline link-underline-opacity-0" href="#them7">Перегрузка операторов</a></li>
                                            <li class="list-group-item"><a class="link-offset-2 link-underline link-underline-opacity-0" href="#them8">Абстрактные классы и методы</a></li>
                                        </ul>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                    <div class="card" style="width: 18rem;">
                        <div class="card-body">
                            <h5 class="card-title">Глава 4. Обработка ошибок и исключений</h5>
                            <div class="accordion-item">
                                <h6 class="accordion-header">
                                    <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse"
                                        data-bs-target="#flush-collapse3" aria-expanded="false"
                                        aria-controls="flush-collapse3">
                                        Темы раздела
                                    </button>
                                </h6>
                                <div id="flush-collapse3" class="accordion-collapse collapse"
                                    data-bs-parent="#accordionFlushExample">
                                    <div class="accordion-body">
                                        <ul class="list-group">
                                            <li class="list-group-item"><a class="link-offset-2 link-underline link-underline-opacity-0" href="pageThem3.html#them1">Конструкция try...except...finally</a></li>
                                            <li class="list-group-item"><a class="link-offset-2 link-underline link-underline-opacity-0" href="pageThem3.html#them2">except и обработка разных типов исключений</a></li>
                                            <li class="list-group-item"><a class="link-offset-2 link-underline link-underline-opacity-0" href="pageThem3.html#them3">Генерация исключений и создание своих типов исключений</a></li>
                                        </ul>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                    <div class="card" style="width: 18rem;">
                        <div class="card-body">
                            <h5 class="card-title">Глава 5. Списки, кортежи и словари</h5>
                            <div class="accordion-item">
                                <h6 class="accordion-header">
                                    <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse"
                                        data-bs-target="#flush-collapse4" aria-expanded="false"
                                        aria-controls="flush-collapse4">
                                        Темы раздела
                                    </button>
                                </h6>
                                <div id="flush-collapse4" class="accordion-collapse collapse"
                                    data-bs-parent="#accordionFlushExample">
                                    <div class="accordion-body">
                                        <ul class="list-group">
                                            <li class="list-group-item"><a class="link-offset-2 link-underline link-underline-opacity-0" href="pageThem4.html#them1">Списки</a></li>
                                            <li class="list-group-item"><a class="link-offset-2 link-underline link-underline-opacity-0" href="pageThem4.html#them2">Кортежи</a></li>
                                            <li class="list-group-item"><a class="link-offset-2 link-underline link-underline-opacity-0" href="pageThem4.html#them3">Диапазоны</a></li>
                                            <li class="list-group-item"><a class="link-offset-2 link-underline link-underline-opacity-0" href="pageThem4.html#them4">Словари</a></li>
                                            <li class="list-group-item"><a class="link-offset-2 link-underline link-underline-opacity-0" href="pageThem4.html#them5">Множества</a></li>
                                            <li class="list-group-item"><a class="link-offset-2 link-underline link-underline-opacity-0" href="pageThem4.html#them6">List comprehension</a></li>
                                            <li class="list-group-item"><a class="link-offset-2 link-underline link-underline-opacity-0" href="pageThem4.html#them7">Упаковка и распаковка</a></li>
                                            <li class="list-group-item"><a class="link-offset-2 link-underline link-underline-opacity-0" href="pageThem4.html#them8">Упаковка и распаковка в параметрах функций</a></li>
                                        </ul>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                    <div class="card" style="width: 18rem;">
                        <div class="card-body">
                            <h5 class="card-title">Глава 6. Модули</h5>
                            <div class="accordion-item">
                                <h6 class="accordion-header">
                                    <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse"
                                        data-bs-target="#flush-collapse5" aria-expanded="false"
                                        aria-controls="flush-collapse5">
                                        Темы раздела
                                    </button>
                                </h6>
                                <div id="flush-collapse5" class="accordion-collapse collapse"
                                    data-bs-parent="#accordionFlushExample">
                                    <div class="accordion-body">
                                        <ul class="list-group">
                                            <li class="list-group-item"><a class="link-offset-2 link-underline link-underline-opacity-0" href="pageThem5.html#them1">Определение и подключение модулей</a></li>
                                            <li class="list-group-item"><a class="link-offset-2 link-underline link-underline-opacity-0" href="pageThem5.html#them2">Генерация байткода модулей</a></li>
                                            <li class="list-group-item"><a class="link-offset-2 link-underline link-underline-opacity-0" href="pageThem5.html#them3">Модуль random</a></li>
                                            <li class="list-group-item"><a class="link-offset-2 link-underline link-underline-opacity-0" href="pageThem5.html#them4">Модуль secrets</a></li>
                                            <li class="list-group-item"><a class="link-offset-2 link-underline link-underline-opacity-0" href="pageThem5.html#them5">Математические функции и модуль math</a></li>
                                            <li class="list-group-item"><a class="link-offset-2 link-underline link-underline-opacity-0" href="pageThem5.html#them6">Модуль locale</a></li>
                                            <li class="list-group-item"><a class="link-offset-2 link-underline link-underline-opacity-0" href="pageThem5.html#them7">Модуль decimal</a></li>
                                            <li class="list-group-item"><a class="link-offset-2 link-underline link-underline-opacity-0" href="pageThem5.html#them8">Модуль dataclasses. Data-классы</a></li>
                                            <li class="list-group-item"><a class="link-offset-2 link-underline link-underline-opacity-0" href="pageThem5.html#them9">Модуль timeit</a></li>
                                            <li class="list-group-item"><a class="link-offset-2 link-underline link-underline-opacity-0" href="pageThem5.html#them10">Установка пакетов, pip и виртуальная среда</a></li>
                                        </ul>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            <div class="col-xl-9">
                <h3>Объектно-ориентированное программирование</h3>
                <div id="them1">
                    <h4>Классы и объекты</h4>
                    <p>Python имеет множество встроенных типов, например, int, str и так далее, которые мы можем использовать в программе. Но также Python позволяет определять собственные типы с помощью классов. Класс представляет некоторую сущность. Конкретным воплощением класса является объект.</p>
                    <p>Можно еще провести следующую аналогию. У нас у всех есть некоторое представление о человеке, у которого есть имя, возраст, какие-то другие характеристики. Человек может выполнять некоторые действия - ходить, бегать, думать и т.д. То есть это представление, которое включает набор характеристик и действий, можно назвать классом. Конкретное воплощение этого шаблона может отличаться, например, одни люди имеют одно имя, другие - другое имя. И реально существующий человек будет представлять объект этого класса.</p>
                    <p>В языке Python класс определяется с помощью ключевого слова class:</p>
                    <pre><code class="codeBlock">
                        <p>class название_класса:</p>
                        <p>    атрибуты_класса</p>
                        <p>    методы_класса</p>
                    </code></pre>
                    <p>Внутри класса определяются его атрибуты, которые хранят различные характеристики класса, и методы - функции класса.</p>
                    <p>Создадим простейший класс:</p>
                    <pre><code class="codeBlock">
                        <p>class Person:</p>
                        <p>    pass</p>
                    </code></pre>
                    <p>В данном случае определен класс Person, который условно представляет человека. В данном случае в классе не определяется никаких методов или атрибутов. Однако поскольку в нем должно быть что-то определено, то в качестве заменителя функционала класса применяется оператор pass. Этот оператор применяется, когда синтаксически необходимо определить некоторый код, однако исходя из задачи код нам не нужен, и вместо конкретного кода вставляем оператор pass.</p>
                    <p>После создания класса можно определить объекты этого класса. Например:</p>
                    <pre><code class="codeBlock">
                        <p>class Person:</p>
                        <p>    pass</p>
                        <p> </p>
                        <p>tom = Person()      # определение объекта tom</p>
                        <p>bob = Person()      # определение объекта bob</p>
                    </code></pre>
                    <p>После определения класса Person создаются два объекта класса Person - tom и bob. Для создания объекта применяется специальная функция - конструктор, которая называется по имени класса и которая возвращает объект класса. То есть в данном случае вызов Person() представляет вызов конструктора. Каждый класс по умолчанию имеет конструктор без параметров:</p>
                    <pre><code class="codeBlock">
                        <p>tom = Person()      # Person() - вызов конструктора, который возвращает объект класса Person</p>
                    </code></pre>
                    <p>Конструкторы</p>
                    <p>Итак, для создания объекта класса используется конструктор. Так, выше когда мы создавали объекты класса Person, мы использовали конструктор по умолчанию, который не принимает параметров и который неявно имеют все классы. Однако мы можем явным образом определить в классах конструктор с помощью специального метода, который называется __init__() (по два прочерка с каждой стороны). К примеру, изменим класс Person, добавив в него конструктор:</p>
                    <pre><code class="codeBlock">
                        <p>class Person:</p>
                        <p>    # конструктор</p>
                        <p>    def __init__(self):</p>
                        <p>        print("Создание объекта Person")</p>
                        <p> </p>
                        <p>tom = Person()      # Создание объекта Person</p>
                    </code></pre>
                    <p>Итак, здесь в коде класса Person определен конструктор - функция __init__. Конструктор должен принимать как минимум один параметр ссылку на текущий объект - self. Обычно конструкторы применяются для определения действий, которые должны производиться при создании объекта.</p>
                    <p>Теперь при создании объекта:</p>
                    <pre><code class="codeBlock">
                        <p>tom = Person()</p>
                    </code></pre>
                    <p>выполняется вызов конструктора __init__() из класса Person, который выведет на консоль строку "Создание объекта Person".</p>
                    <p>Стоит отметить, что конструктор фактически представляет обычную функцию, только для вызовы конструктора используется не __init__, а название класса. Кроме того, при вызове конструктора параметру self явным образом не передается никакого значения. При выполнении программы Python динамически будет определять self.</p>
                    <p>Атрибуты объекта</p>
                    <p>Атрибуты хранят состояние объекта. Для определения и установки атрибутов внутри класса можно применять слово self. Например, определим следующий класс Person:</p>
                    <pre><code class="codeBlock">
                        <p>class Person:</p>
                        <p> </p>
                        <p>    def __init__(self, name, age):</p>
                        <p>        self.name = name    # имя человека</p>
                        <p>        self.age = age        # возраст человека</p>
                        <p> </p>
                        <p> </p>
                        <p>tom = Person("Tom", 22)</p>
                        <p> </p>
                        <p># обращение к атрибутам</p>
                        <p># получение значений</p>
                        <p>print(tom.name)     # Tom</p>
                        <p>print(tom.age)      # 22</p>
                        <p># изменение значения</p>
                        <p>tom.age = 37</p>
                        <p>print(tom.age)      # 37</p>
                    </code></pre>
                    <p>Теперь конструктор класса Person принимает еще два параметра - name и age. Через эти параметры в конструктор будут передаваться имя и возраст создаваемого человека.</p>
                    <p>Внутри конструктора устанавливаются два атрибута - name и age (условно имя и возраст человека):</p>
                    <pre><code class="codeBlock">
                        <p>def __init__(self, name, age):</p>
                        <p>    self.name = name</p>
                        <p>    self.age = age</p>
                    </code></pre>
                    <p>Атрибуту self.name присваивается значение переменной name. Атрибут age получает значение параметра age. Название атрибутов не обязательно должно соответствовать названиям параметров.</p>
                    <p>Если мы определили в классе конструктор __init__ с параметрами (кроме self), то при вызове конструктора этим параметрам надо передать значения:</p>
                    <pre><code class="codeBlock">
                        <p>tom = Person("Tom", 22)</p>
                    </code></pre>
                    <p>То есть в данном случае параметру name передается строка "Tom", а параметру age - число 22.</p>
                    <p>Далее по имени объекта мы можем обращаться к атрибутам объекта - получать и изменять их значения:</p>
                    <pre><code class="codeBlock">
                        <p>print(tom.name)     # получение значения атрибута name</p>
                        <p>tom.age = 37        # изменение значения атрибута age</p>
                    </code></pre>
                    <p>Подобным образом мы можем создавать разные объекты класса Person с разным значением для атрибутов:</p>
                    <pre><code class="codeBlock">
                        <p>class Person:</p>
                        <p> </p>
                        <p>    def __init__(self, name, age):</p>
                        <p>        self.name = name    # имя человека</p>
                        <p>        self.age = age        # возраст человека</p>
                        <p> </p>
                        <p> </p>
                        <p>tom = Person("Tom", 22)</p>
                        <p>bob = Person("Bob", 43)</p>
                        <p> </p>
                        <p>print(tom.name)         # Tom</p>
                        <p>print(bob.name)         # Bob</p>
                    </code></pre>
                    <p>Здесь создаются два объекта класса Person: tom и bob. Они соответствуют определению класса Person, имеют одинаковый набор атрибутов, однако их состояние будет отличаться. И в каждом случае Python будет динамически определять объект self. Так, в следующем случае</p>
                    <pre><code class="codeBlock">
                        <p>tom = Person("Tom", 22)</p>
                    </code></pre>
                    <p>Это будет объект tom</p>
                    <p>А при вызове</p>
                    <pre><code class="codeBlock">
                        <p>bob = Person("Bob", 43)</p>
                    </code></pre>
                    <p>Это будет объект bob</p>
                    <p>В принципе нам необязательно определять атрибуты внутри класса - Python позволяет сделать это динамически вне кода:</p>
                    <pre><code class="codeBlock">
                        <p>class Person:</p>
                        <p> </p>
                        <p>    def __init__(self, name, age):</p>
                        <p>        self.name = name        # имя человека</p>
                        <p>        self.age = age          # возраст человека</p>
                        <p> </p>
                        <p> </p>
                        <p>tom = Person("Tom", 22)</p>
                        <p> </p>
                        <p>tom.company = "Microsoft"</p>
                        <p>print(tom.company)  # Microsoft</p>
                    </code></pre>
                    <p>Здесь динамически устанавливается атрибут company, который хранит место работы человека. И после установки мы также можем получить его значение. В то же время подобное определение чревато ошибками. Например, если мы попытаемся обратиться к атрибуту до его определения, то программа сгенерирует ошибку:</p>
                    <pre><code class="codeBlock">
                        <p>tom = Person("Tom", 22)</p>
                        <p>print(tom.company)  # ! Ошибка - AttributeError: Person object has no attribute company</p>
                    </code></pre>
                    <p>Методы классов</p>
                    <p>Методы класса фактически представляют функции, которые определенны внутри класса и которые определяют его поведение. Например, определим класс Person с одним методом:</p>
                    <pre><code class="codeBlock">
                        <p>class Person:       # определение класса Person</p>
                        <p>     def say_hello(self):</p>
                        <p>        print("Hello")</p>
                        <p> </p>
                        <p>tom = Person()</p>
                        <p>tom.say_hello()    # Hello</p>
                    </code></pre>
                    <p>Здесь определен метод say_hello(), который условно выполняет приветствие - выводит строку на консоль. При определении методов любого класса, как и конструктора, первый параметр метода представляет ссылку на текущий объект, который согласно условностям называется self. Через эту ссылку внутри класса мы можем обратиться к функциональности текущего объекта. Но при самом вызове метода этот параметр не учитывается.</p>
                    <p>Используя имя объекта, мы можем обратиться к его методам. Для обращения к методам применяется нотация точки - после имени объекта ставится точка и после нее идет вызов метода:</p>
                    <p>объект.метод([параметры метода])</p>
                    <p>Например, обращение к методу say_hello() для вывода приветствия на консоль:</p>
                    <pre><code class="codeBlock">
                        <p>tom.say_hello()    # Hello</p>
                    </code></pre>
                    <p>В итоге данная программа выведет на консоль строку "Hello".</p>
                    <p>Если метод должен принимать другие параметры, то они определяются после параметра self, и при вызове подобного метода для них необходимо передать значения:</p>
                    <pre><code class="codeBlock">
                        <p>class Person:       # определение класса Person</p>
                        <p>    def say(self, message):     # метод </p>
                        <p>        print(message)</p>
                        <p> </p>
                        <p>tom = Person()</p>
                        <p>tom.say("Hello METANIT.COM")    # Hello METANIT.COM</p>
                    </code></pre>
                    <p>Здесь определен метод say(). Он принимает два параметра: self и message. И для второго параметра - message при вызове метода необходимо передать значение.</p>
                    <p>Для обращения к атрибутам и методам объекта внутри класса в его методах также применяется слово self:</p>
                    <pre><code class="codeBlock">
                        <p>self.атрибут    # обращение к атрибуту</p>
                        <p>self.метод      # обращение к методу</p>
                    </code></pre>
                    <p>Например, следующий класс Person:</p>
                    <pre><code class="codeBlock">
                        <p>class Person:</p>
                        <p> </p>
                        <p>    def __init__(self, name, age):</p>
                        <p>        self.name = name        # имя человека</p>
                        <p>        self.age = age          # возраст человека</p>
                        <p>     </p>
                        <p>    def display_info(self):</p>
                        <p>        print(f"Name: {self.name}  Age: {self.age}")</p>
                        <p> </p>
                        <p> </p>
                        <p>tom = Person("Tom", 22)</p>
                        <p>tom.display_info()      # Name: Tom  Age: 22</p>
                        <p> </p>
                        <p>bob = Person("Bob", 43)</p>
                        <p>bob.display_info()      # Name: Bob  Age: 43</p>
                        <p>Здесь определяется метод display_info(), который выводит информацию на консоль. И для обращения в методе к атрибутам объекта применяется слово self: self.name и self.age</p>
                        <p>В итоге мы получим следующий консольный вывод:</p>
                        <p>Name: Tom  Age: 22</p>
                        <p>Name: Bob  Age: 43</p>
                    </code></pre>
                    <p>Деструкторы</p>
                    <p>Кроме конструкторов классы в Python также могут определять специальные методы - деструкторы, которые вызываются при удалении объекта. Деструктор представляет собой метод __del__(self), в который, как и в конструктор, передается ссылка на текущий объект. В деструкторе определяются действия, которые надо выполнить при удалении объекта, например, освобождение или удаление каких-то ресурсов, которые использовал объект.</p>
                    <p>Деструктор вызывается автоматически интерпретатором, нам не нужно его явным образом вызывать. Простейший пример:</p>
                    <pre><code class="codeBlock">
                        <p>class Person:</p>
                        <p>  </p>
                        <p>    def __init__(self, name):</p>
                        <p>        self.name = name</p>
                        <p>        print("Создан человек с именем", self.name)</p>
                        <p>     </p>
                        <p>    def __del__(self):</p>
                        <p>        print("Удален человек с именем", self.name)</p>
                        <p>  </p>
                        <p>tom = Person("Tom")</p>
                    </code></pre>
                    <p>Здесь в деструкторе просто выведится уведомление об удалении объекта Person. Программа создает один объект Person и хранит ссылку на него в переменной tom. Создание объекта вызовет выполнение конструктора. При завершении программы автоматически будет выполняться деструктор объекта tom. В итоге консольный вывод программы будет следующим:</p>
                    <p>Создан человек с именем Tom</p>
                    <p>Удален человек с именем Tom</p>
                    <p>Другой пример:</p>
                    <pre><code class="codeBlock">
                        <p>class Person:</p>
                        <p>  </p>
                        <p>    def __init__(self, name):</p>
                        <p>        self.name = name</p>
                        <p>        print("Создан человек с именем", self.name)</p>
                        <p>     </p>
                        <p>    def __del__(self):</p>
                        <p>        print("Удален человек с именем", self.name)</p>
                        <p>  </p>
                        <p> </p>
                        <p>def create_person():</p>
                        <p>    tom = Person("Tom")</p>
                        <p>     </p>
                        <p>create_person()</p>
                        <p>print("Конец программы")</p>
                    </code></pre>
                    <p>Здесь объект Person создается и используется внутри функции create_person, поэтому жизнь создаваемого объекта Person ограничена областью этой функции. Соответственно, когда функция завершит свое выполнение, у объекта Person будет вызываться деструктор. В итоге мы получим следующий консольный вывод:</p>
                    <p>Создан человек с именем Tom</p>
                    <p>Удален человек с именем Tom</p>
                    <p>Конец программы</p>
                </div>
                <div id="them2">
                    <h4>Инкапсуляция, атрибуты и свойства</h4>
                    <p>По умолчанию атрибуты в классах являются общедоступными, а это значит, что из любого места программы мы можем получить атрибут объекта и изменить его. Например:</p>
                    <pre><code class="codeBlock">
                        <p>class Person:</p>
                        <p>    def __init__(self, name, age):</p>
                        <p>        self.name = name    # устанавливаем имя</p>
                        <p>        self.age = age      # устанавливаем возраст</p>
                        <p>                 </p>
                        <p>    def print_person(self):</p>
                        <p>        print(f"Имя: {self.name}\tВозраст: {self.age}")</p>
                        <p>         </p>
                        <p> </p>
                        <p>tom = Person("Tom", 39)</p>
                        <p>tom.name = "Человек-паук"       # изменяем атрибут name</p>
                        <p>tom.age = -129                  # изменяем атрибут age</p>
                        <p>tom.print_person()              # Имя: Человек-паук     Возраст: -129</p>
                    </code></pre>
                    <p>Но в данном случае мы можем, к примеру, присвоить возрасту или имени человека некорректное значение, например, указать отрицательный возраст. Подобное поведение нежелательно, поэтому встает вопрос о контроле за доступом к атрибутам объекта.</p>
                    <p>С данной проблемой тесно связано понятие инкапсуляции. Инкапсуляция является фундаментальной концепцией объектно-ориентированного программирования, которая предполагает скрытие функционала и предотвращение прямого доступа извне к нему.</p>
                    <p>Язык программирования Python позволяет определить приватные или закрытые атрибуты. Для этого имя атрибута должно начинаться с двойного подчеркивания - __name. Например, перепишем предыдущую программу, сделав оба атрибута - name и age приватными:</p>
                    <pre><code class="codeBlock">
                        <p>class Person:</p>
                        <p>    def __init__(self, name, age):</p>
                        <p>        self.__name = name    # устанавливаем имя</p>
                        <p>        self.__age = age       # устанавливаем возраст</p>
                        <p>                  </p>
                        <p>    def print_person(self):</p>
                        <p>        print(f"Имя: {self.__name}\tВозраст: {self.__age}")</p>
                        <p>          </p>
                        <p>  </p>
                        <p>tom = Person("Tom", 39)</p>
                        <p>tom.__name = "Человек-паук"     # пытаемся изменить атрибут __name</p>
                        <p>tom.__age = -129                # пытаемся изменить атрибут __</p>
                        <p>tom.print_person()              # Имя: Tom        Возраст: 39</p>
                    </code></pre>
                    <p>В принципе мы также можем попытаться установить для атрибутов __name и __age новые значения:</p>
                    <pre><code class="codeBlock">
                        <p>tom.__name = "Человек-паук"     # пытаемся изменить атрибут __name</p>
                        <p>tom.__age = -129                # пытаемся изменить атрибут __</p>
                    </code></pre>
                    <p>Но вывод метода print_person покажет, что атрибуты объекта не изменили свои значения:</p>
                    <pre><code class="codeBlock">
                        <p>tom.print_person()       # Имя: Tom        Возраст: 39</p>
                    </code></pre>
                    <p>Как это работает? При объявлении атрибута, имя которого начинается с двух прочерков, например, __attribute, Python в реальности определяет атрибута, который называется по шаблону _ClassName__atribute. То есть в случае выше будут создаваться атрибуты _Person__name и _Person__age. Поэтому к такому атрибуту мы сможем обратиться только из того же класса. Но не сможем обратиться вне этого класса. Например, присвоение значения этому атрибуту ничего не даст:</p>
                    <pre><code class="codeBlock">
                        <p>tom.__age = 43 </p>
                    </code></pre>
                    <p>Потому что в данном случае просто определяется динамически новый атрибут __age, но это он не имеет ничего общего с атрибутом self.__age или точнее self._Person__age.</p>
                    <p>А попытка получить его значение приведет к ошибке выполнения (если ранее не была определена переменная __age):</p>
                    <pre><code class="codeBlock">
                        <p>print(tom.__age)</p>
                    </code></pre>
                    <p>Тем не менее приватность атрибутов тут довольно относительна. Например, мы можем использовать полное имя атрибута:</p>
                    <pre><code class="codeBlock">
                        <p>class Person:</p>
                        <p>    def __init__(self, name, age):</p>
                        <p>        self.__name = name    # устанавливаем имя</p>
                        <p>        self.__age = age       # устанавливаем возраст</p>
                        <p>                  </p>
                        <p>    def print_person(self):</p>
                        <p>        print(f"Имя: {self.__name}\tВозраст: {self.__age}")</p>
                        <p>          </p>
                        <p>  </p>
                        <p>tom = Person("Tom", 39)</p>
                        <p>tom._Person__name = "Человек-паук"     # изменяем атрибут __name</p>
                        <p>tom.print_person()              # Имя: Человек-паук        Возраст: 39</p>
                    </code></pre>
                    <p>Тем нее менее автор внешнего кода еще должен угадать, как называются атрибуты.</p>
                    <p>Методы доступа. Геттеры и сеттеры</p>
                    <p>Может возникнуть вопрос, как обращаться к подобным приватным атрибутам. Для этого обычно применяются специальные методы доступа. Геттер позволяет получить значение атрибута, а сеттер установить его. Так, изменим выше определенный класс, определив в нем методы доступа:</p>
                    <pre><code class="codeBlock">
                        <p>class Person:</p>
                        <p>    def __init__(self, name, age):</p>
                        <p>        self.__name = name    # устанавливаем имя</p>
                        <p>        self.__age = age       # устанавливаем возраст</p>
                        <p> </p>
                        <p>    # сеттер для установки возраста</p>
                        <p>    def set_age(self, age):</p>
                        <p>        if 0 < age < 110:</p>
                        <p>            self.__age = age</p>
                        <p>        else:</p>
                        <p>            print("Недопустимый возраст")</p>
                        <p> </p>
                        <p>    # геттер для получения возраста</p>
                        <p>    def get_age(self):</p>
                        <p>        return self.__age</p>
                        <p> </p>
                        <p>    # геттер для получения имени</p>
                        <p>    def get_name(self):</p>
                        <p>        return self.__name</p>
                        <p>     </p>
                        <p>    def print_person(self):</p>
                        <p>        print(f"Имя: {self.__name}\tВозраст: {self.__age}")</p>
                        <p>          </p>
                        <p>  </p>
                        <p>tom = Person("Tom", 39)</p>
                        <p>tom.print_person()  # Имя: Tom  Возраст: 39</p>
                        <p>tom.set_age(-3486)  # Недопустимый возраст</p>
                        <p>tom.set_age(25)</p>
                        <p>tom.print_person()  # Имя: Tom  Возраст: 25</p>
                    </code></pre>
                    <p>Для получения значения возраста применяется метод get_age:</p>
                    <pre><code class="codeBlock">
                        <p>def get_age(self):</p>
                        <p>    return self.__age</p>
                    </code></pre>
                    <p>Для изменения возраста определен метод set_age:</p>
                    <pre><code class="codeBlock">
                        <p>def set_age(self, age):</p>
                        <p>    if 0 < age < 110:</p>
                        <p>        self.__age = age</p>
                        <p>    else:</p>
                        <p>        print("Недопустимый возраст")</p>
                    </code></pre>
                    <p>Причем опосредование доступа к атрибутам через методы позволяет задать дополнительную логику. Так, в зависимости от переданного возраста мы можем решить, надо ли переустанавливать возраст, так как переданное значение может быть некорректным.</p>
                    <p>Также еобязательно создавать для каждого приватного атрибута подобную пару методов. Так, в примере выше имя человека мы можем установить только из конструктора. А для получение определен метод get_name.</p>
                    <p>Аннотации свойств</p>
                    <p>Выше мы рассмотрели, как создавать методы доступа. Но Python имеет также еще один - более элегантный способ - свойства. Этот способ предполагает использование аннотаций, которые предваряются символом @.</p>
                    <p>Для создания свойства-геттера над свойством ставится аннотация @property.</p>
                    <p>Для создания свойства-сеттера над свойством устанавливается аннотация имя_свойства_геттера.setter.</p>
                    <p>Перепишем класс Person с использованием аннотаций:</p>
                    <pre><code class="codeBlock">
                        <p>class Person:</p>
                        <p>    def __init__(self, name, age):</p>
                        <p>        self.__name = name    # устанавливаем имя</p>
                        <p>        self.__age = age       # устанавливаем возраст</p>
                        <p> </p>
                        <p>    # свойство-геттер</p>
                        <p>    @property</p>
                        <p>    def age(self):</p>
                        <p>        return self.__age</p>
                        <p>    # свойство-сеттер</p>
                        <p>    @age.setter</p>
                        <p>    def age(self, age):</p>
                        <p>        if 0 < age < 110:</p>
                        <p>            self.__age = age</p>
                        <p>        else:</p>
                        <p>            print("Недопустимый возраст")</p>
                        <p> </p>
                        <p>    @property</p>
                        <p>    def name(self):</p>
                        <p>        return self.__name</p>
                        <p>     </p>
                        <p>    def print_person(self):</p>
                        <p>        print(f"Имя: {self.__name}\tВозраст: {self.__age}")</p>
                        <p>          </p>
                        <p>  </p>
                        <p>tom = Person("Tom", 39)</p>
                        <p>tom.print_person()  # Имя: Tom  Возраст: 39</p>
                        <p>tom.age = -3486     # Недопустимый возраст  (Обращение к сеттеру)</p>
                        <p>print(tom.age)      # 39 (Обращение к геттеру)</p>
                        <p>tom.age = 25        # (Обращение к сеттеру)</p>
                        <p>tom.print_person()  # Имя: Tom  Возраст: 25</p>
                    </code></pre>
                    <p>Во-первых, стоит обратить внимание, что свойство-сеттер определяется после свойства-геттера.</p>
                    <p>Во-вторых, и сеттер, и геттер называются одинаково - age. И поскольку геттер называется age, то над сеттером устанавливается аннотация @age.setter.</p>
                    <p>После этого, что к геттеру, что к сеттеру, мы обращаемся через выражение tom.age.</p>
                    <p>При этом можно определить только геттер, как в случае с свойством name - его нельзя изменить, а можно лишь получить значение.</p>
                </div>
                <div id="them3">
                    <h4>Наследование</h4>
                    <p>Наследование позволяет создавать новый класс на основе уже существующего класса. Наряду с инкапсуляцией наследование является одним из краеугольных камней объектно-ориентированного программирования.</p>
                    <p>Ключевыми понятиями наследования являются подкласс и суперкласс. Подкласс наследует от суперкласса все публичные атрибуты и методы. Суперкласс еще называется базовым (base class) или родительским (parent class), а подкласс - производным (derived class) или дочерним (child class).</p>
                    <p>Синтаксис для наследования классов выглядит следующим образом:</p>
                    <pre><code class="codeBlock">
                        <p>class подкласс (суперкласс):</p>
                        <p>    методы_подкласса</p>
                    </code></pre>
                    <p>Например, у нас есть класс Person, который представляет человека:</p>
                    <pre><code class="codeBlock">
                        <p>class Person:</p>
                        <p> </p>
                        <p>    def __init__(self, name):</p>
                        <p>        self.__name = name   # имя человека</p>
                        <p> </p>
                        <p>    @property</p>
                        <p>    def name(self):</p>
                        <p>        return self.__name</p>
                        <p>     </p>
                        <p>    def display_info(self):</p>
                        <p>        print(f"Name: {self.__name} ")</p>
                    </code></pre>
                    <p>Предположим, нам необходим класс работника, который работает на некотором предприятии. Мы могли бы создать с нуля новый класс, к примеру, класс Employee:</p>
                    <pre><code class="codeBlock">
                        <p>class Employee:</p>
                        <p> </p>
                        <p>    def __init__(self, name):</p>
                        <p>        self.__name = name  # имя работника</p>
                        <p> </p>
                        <p>    @property</p>
                        <p>    def name(self):</p>
                        <p>        return self.__name</p>
                        <p> </p>
                        <p>    def display_info(self):</p>
                        <p>        print(f"Name: {self.__name} ")</p>
                        <p> </p>
                        <p>    def work(self):</p>
                        <p>        print(f"{self.name} works")</p>
                    </code></pre>
                    <p>Однако класс Employee может иметь те же атрибуты и методы, что и класс Person, так как работник - это человек. Так, в выше в классе Employee только добавляется метод works, весь остальной код повторяет функционал класса Person. Но чтобы не дублировать функционал одного класса в другом, в данном случае лучше применить наследование.</p>
                    <p>Итак, унаследуем класс Employee от класса Person:</p>
                    <pre><code class="codeBlock">
                        <p>class Person:</p>
                        <p> </p>
                        <p>    def __init__(self, name):</p>
                        <p>        self.__name = name   # имя человека</p>
                        <p> </p>
                        <p>    @property</p>
                        <p>    def name(self):</p>
                        <p>        return self.__name</p>
                        <p> </p>
                        <p>    def display_info(self):</p>
                        <p>        print(f"Name: {self.__name} ")</p>
                        <p> </p>
                        <p> </p>
                        <p>class Employee(Person):</p>
                        <p> </p>
                        <p>    def work(self):</p>
                        <p>        print(f"{self.name} works")</p>
                        <p> </p>
                        <p> </p>
                        <p>tom = Employee("Tom")</p>
                        <p>print(tom.name)     # Tom</p>
                        <p>tom.display_info()  # Name: Tom </p>
                        <p>tom.work()          # Tom works</p>
                    </code></pre>
                    <p>Класс Employee полностью перенимает функционал класса Person, лишь добавляя метод work(). Соответственно при создании объекта Employee мы можем использовать унаследованный от Person конструктор:</p>
                    <pre><code class="codeBlock">
                        <p>tom = Employee("Tom")</p>
                    </code></pre>
                    <p>И также можно обращаться к унаследованным атрибутам/свойствам и методам:</p>
                    <pre><code class="codeBlock">
                        <p>print(tom.name)     # Tom</p>
                        <p>tom.display_info()  # Name: Tom</p>
                    </code></pre>
                    <p>Однако, стоит обратить внимание, что для Employee НЕ доступны закрытые атрибуты типа __name. Например, мы НЕ можем в методе work обратиться к приватному атрибуту self.__name:</p>
                    <pre><code class="codeBlock">
                        <p>def work(self):</p>
                        <p>    print(f"{self.__name} works")   # ! Ошибка</p>
                    </code></pre>
                    <p>Множественное наследование</p>
                    <p>Одной из отличительных особенностей языка Python является поддержка множественного наследования, то есть один класс можно унаследовать от нескольких классов:</p>
                    <pre><code class="codeBlock">
                        <p>#  класс работника</p>
                        <p>class Employee:</p>
                        <p>    def work(self):</p>
                        <p>        print("Employee works")</p>
                        <p> </p>
                        <p> </p>
                        <p>#  класс студента</p>
                        <p>class Student:</p>
                        <p>    def study(self):</p>
                        <p>        print("Student studies")</p>
                        <p> </p>
                        <p> </p>
                        <p>class WorkingStudent(Employee, Student):        # Наследование от классов Employee и Student</p>
                        <p>    pass</p>
                        <p> </p>
                        <p> </p>
                        <p># класс работающего студента</p>
                        <p>tom = WorkingStudent()</p>
                        <p>tom.work()      # Employee works</p>
                        <p>tom.study()     # Student studies</p>
                    </code></pre>
                    <p>Здесь определен класс Employee, который представляет сотрудника фирмы, и класс Student, который представляет учащегося студента. Класс WorkingStudent, который представляет работающего студента, не определяет никакого функционала, поэтому в нем определен оператор pass. Класс WorkingStudent просто наследует функционал от двух классов Employee и Student. Соответственно у объекта этого класса мы можем вызвать методы обоих классов.</p>
                    <p>При этом наследуемые классы могут более сложными по функциональности, например:</p>
                    <pre><code class="codeBlock">
                        <p>class Employee:</p>
                        <p> </p>
                        <p>    def __init__(self, name):</p>
                        <p>        self.__name = name</p>
                        <p> </p>
                        <p>    @property</p>
                        <p>    def name(self):</p>
                        <p>        return self.__name</p>
                        <p> </p>
                        <p>    def work(self):</p>
                        <p>        print(f"{self.name} works")</p>
                        <p> </p>
                        <p> </p>
                        <p>class Student:</p>
                        <p> </p>
                        <p>    def __init__(self, name):</p>
                        <p>        self.__name = name</p>
                        <p> </p>
                        <p>    @property</p>
                        <p>    def name(self):</p>
                        <p>        return self.__name</p>
                        <p> </p>
                        <p>    def study(self):</p>
                        <p>        print(f"{self.name} studies")</p>
                        <p> </p>
                        <p> </p>
                        <p>class WorkingStudent(Employee, Student):</p>
                        <p>    pass</p>
                        <p> </p>
                        <p> </p>
                        <p>tom = WorkingStudent("Tom")</p>
                        <p>tom.work()      # Tom works</p>
                        <p>tom.study()     # Tom studies</p>
                    </code></pre>
                    <p>Множественное наследование может показаться удобным, тем не менее оно может привести к путанице, если оба наследуемых класса содержат методы/атрибуты с одинаковыми именами. Например:</p>
                    <pre><code class="codeBlock">
                        <p>class Employee:</p>
                        <p>    def do(self):</p>
                        <p>        print("Employee works")</p>
                        <p>  </p>
                        <p>class Student:</p>
                        <p>    def do(self):</p>
                        <p>        print("Student studies")</p>
                        <p>  </p>
                        <p>  </p>
                        <p># class WorkingStudent(Student,Employee):</p>
                        <p>class WorkingStudent(Employee, Student):</p>
                        <p>    pass</p>
                        <p> </p>
                        <p>tom = WorkingStudent()</p>
                        <p>tom.do()     # ?</p>
                    </code></pre>
                    <p>Оба базовых класса - Employee и Worker определяют метод do, который выводит разную строку на консоль. Какую именно из этих реализаций будет использовать класс-наследник WorkingStudent? При определении класса первым в списке базовых классов идет класс Employee</p>
                    <p>class WorkingStudent(Employee, Student)</p>
                    <p>Поэтому реализация метода do будут браться из класса Employee.</p>
                    <p>Если бы мы поменяли очередность классов:</p>
                    <p>class WorkingStudent(Student,Employee)</p>
                    <p>то использовалась бы реализация класса Student</p>
                    <p>При необходимости мы можем программным образом посмотреть очередность применения функционала базовых классов. Для этого применяется атрибут __mro__, либо метод mro():</p>
                    <pre><code class="codeBlock">
                        <p>print(WorkingStudent.__mro__)</p>
                        <p>print(WorkingStudent.mro())</p>
                    </code></pre>
                </div>
                <div id="them4">
                    <h4>Переопределение функционала базового класса</h4>
                    <p>В прошлой статье класс Employee полностью перенимал функционал класса Person:</p>
                    <pre><code class="codeBlock">
                        <p>class Person:</p>
                        <p> </p>
                        <p>    def __init__(self, name):</p>
                        <p>        self.__name = name   # имя человека</p>
                        <p> </p>
                        <p>    @property</p>
                        <p>    def name(self):</p>
                        <p>        return self.__name</p>
                        <p> </p>
                        <p>    def display_info(self):</p>
                        <p>        print(f"Name: {self.__name} ")</p>
                        <p> </p>
                        <p> </p>
                        <p>class Employee(Person):</p>
                        <p> </p>
                        <p>    def work(self):</p>
                        <p>        print(f"{self.name} works")</p>
                    </code></pre>
                    <p>Но что, если мы хотим что-то изменить из этого функционала? Например, добавить работнику через конструктор, новый атрибут, который будет хранить компанию, где он работает или изменить реализацию метода display_info. Python позволяет переопределить функционал базового класса.</p>
                    <p>Например, изменим классы следующим образом:</p>
                    <pre><code class="codeBlock">
                        <p>class Person:</p>
                        <p> </p>
                        <p>    def __init__(self, name):</p>
                        <p>        self.__name = name   # имя человека</p>
                        <p> </p>
                        <p>    @property</p>
                        <p>    def name(self):</p>
                        <p>        return self.__name</p>
                        <p> </p>
                        <p>    def display_info(self):</p>
                        <p>        print(f"Name: {self.__name}")</p>
                        <p> </p>
                        <p> </p>
                        <p>class Employee(Person):</p>
                        <p> </p>
                        <p>    def __init__(self, name, company):</p>
                        <p>        super().__init__(name)</p>
                        <p>        self.company = company</p>
                        <p> </p>
                        <p>    def display_info(self):</p>
                        <p>        super().display_info()</p>
                        <p>        print(f"Company: {self.company}")</p>
                        <p> </p>
                        <p>    def work(self):</p>
                        <p>        print(f"{self.name} works")</p>
                        <p> </p>
                        <p> </p>
                        <p>tom = Employee("Tom", "Microsoft")</p>
                        <p>tom.display_info()  # Name: Tom</p>
                        <p>                    # Company: Microsoft</p>
                    </code></pre>
                    <p>Здесь в классе Employee добавляется новый атрибут - self.company, который хранит компания работника. Соответственно метод __init__() принимает три параметра: второй для установки имени и третий для установки компании. Но если в базом классе определен конструктор с помощью метода __init__, и мы хотим в производном классе изменить логику конструктора, то в конструкторе производного класса мы должны вызвать конструктор базового класса. То есть в конструкторе Employee надо вызвать конструктор класса Person.</p>
                    <p>Для обращения к базовому классу используется выражение super(). Так, в конструкторе Employee выполняется вызов:</p>
                    <pre><code class="codeBlock">
                        <p>super().__init__(name)</p>
                    </code></pre>
                    <p>Это выражение будет представлять вызов конструктора класса Person, в который передается имя работника. И это логично. Ведь имя работника устанавливается именно в конструкторе класса Person. В самом конструкторе Employee лишь устанавливаем свойство company.</p>
                    <p>Кроме того, в классе Employee переопределяется метод display_info() - в него добавляется вывод компании работника. Причем мы могли определить этот метод следующим образом:</p>
                    <pre><code class="codeBlock">
                        <p>def display_info(self):</p>
                        <p>    print(f"Name: {self.name}")</p>
                        <p>    print(f"Company: {self.company}")</p>
                    </code></pre>
                    <p>Но тогда строка вывода имени повторяла бы код из класса Person. Если эта часть кода совпадает с методом из класса Person, то нет смысла повторяться, поэтому опять же с помощью выражения super() обращаемся к реализации метода display_info в классе Person:</p>
                    <pre><code class="codeBlock">
                        <p>def display_info(self):</p>
                        <p>    super().display_info()      # обращение к методу display_info в классе Person</p>
                        <p>    print(f"Company: {self.company}")</p>
                    </code></pre>
                    <p>Затем мы можем вызвать вызвать конструктор Employee для создания объекта этого класса и вызвать метод display_info:</p>
                    <pre><code class="codeBlock">
                        <p>tom = Employee("Tom", "Microsoft")</p>
                        <p>tom.display_info()</p>
                        <p>Консольный вывод программы:</p>
                        <p>Name: Tom</p>
                        <p>Company: Microsoft</p>
                    </code></pre>
                    <p>Проверка типа объекта</p>
                    <p>При работе с объектами бывает необходимо в зависимости от их типа выполнить те или иные операции. И с помощью встроенной функции isinstance() мы можем проверить тип объекта. Эта функция принимает два параметра:</p>
                    <p>isinstance(object, type)</p>
                    <p>Первый параметр представляет объект, а второй - тип, на принадлежность к которому выполняется проверка. Если объект представляет указанный тип, то функция возвращает True. Например, возьмем следующую иерархию классов Person-Employee/Student:</p>
                    <pre><code class="codeBlock">
                        <p>class Person:</p>
                        <p> </p>
                        <p>    def __init__(self, name):</p>
                        <p>        self.__name = name   # имя человека</p>
                        <p> </p>
                        <p>    @property</p>
                        <p>    def name(self):</p>
                        <p>        return self.__name</p>
                        <p> </p>
                        <p>    def do_nothing(self):</p>
                        <p>        print(f"{self.name} does nothing")</p>
                        <p> </p>
                        <p> </p>
                        <p>#  класс работника</p>
                        <p>class Employee(Person):</p>
                        <p> </p>
                        <p>    def work(self):</p>
                        <p>        print(f"{self.name} works")</p>
                        <p> </p>
                        <p> </p>
                        <p>#  класс студента</p>
                        <p>class Student(Person):</p>
                        <p> </p>
                        <p>    def study(self):</p>
                        <p>        print(f"{self.name} studies")</p>
                        <p> </p>
                        <p> </p>
                        <p>def act(person):</p>
                        <p>    if isinstance(person, Student):</p>
                        <p>        person.study()</p>
                        <p>    elif isinstance(person, Employee):</p>
                        <p>        person.work()</p>
                        <p>    elif isinstance(person, Person):</p>
                        <p>        person.do_nothing()</p>
                        <p> </p>
                        <p> </p>
                        <p>tom = Employee("Tom")</p>
                        <p>bob = Student("Bob")</p>
                        <p>sam = Person("Sam")</p>
                        <p> </p>
                        <p>act(tom)    # Tom works</p>
                        <p>act(bob)    # Bob studies</p>
                        <p>act(sam)    # Sam does nothing</p>
                    </code></pre>
                    <p>Здесь класс Employee определяет метод work(), а класс Student - метод study.</p>
                    <p>Здесь также определена функция act, которая проверяет с помощью функции isinstance, представляет ли параметр person определнный тип, и зависимости от результатов проверки обращается к определенному методу объекта.</p>
                </div>
                <div id="them5">
                    <h4>Атрибуты классов и статические методы</h4>
                    <p>Атрибуты класса</p>
                    <p>Кроме атрибутов объектов в классе можно определять атрибуты классов. Подобные атрибуты определяются в виде переменных уровня класса. Например:</p>
                    <pre><code class="codeBlock">
                        <p>class Person:</p>
                        <p>     type = "Person"</p>
                        <p>     description = "Describes a person"</p>
                        <p> </p>
                        <p> </p>
                        <p>print(Person.type)          # Person</p>
                        <p>print(Person.description)   # Describes a person</p>
                        <p> </p>
                        <p>Person.type = "Class Person"</p>
                        <p>print(Person.type)          # Class Person</p>
                    </code></pre>
                    <p>Здесь в классе Person определено два атрибута: type, который хранит имя класса, и description, который хранит описание класса.</p>
                    <p>Для обращения к атрибутам класса мы можем использовать имя класса, например: Person.type, и, как и атрибуты объекта, мы можем получать и изменять их значения.</p>
                    <p>Подобные атрибуты являются общими для всех объектов класса:</p>
                    <pre><code class="codeBlock">
                        <p>class Person:</p>
                        <p>     type = "Person"</p>
                        <p>     def __init__(self, name):</p>
                        <p>         self.name = name</p>
                        <p> </p>
                        <p> </p>
                        <p>tom = Person("Tom")</p>
                        <p>bob = Person("Bob")</p>
                        <p>print(tom.type)     # Person</p>
                        <p>print(bob.type)     # Person</p>
                        <p> </p>
                        <p># изменим атрибут класса</p>
                        <p>Person.type = "Class Person"</p>
                        <p>print(tom.type)     # Class Person</p>
                        <p>print(bob.type)     # Class Person</p>
                    </code></pre>
                    <p>Атрибуты класса могут применяться для таких ситуаций, когда нам надо определить некоторые общие данные для всех объектов. Например:</p>
                    <pre><code class="codeBlock">
                        <p>class Person:</p>
                        <p>    default_name = "Undefined"</p>
                        <p> </p>
                        <p>    def __init__(self, name):</p>
                        <p>        if name:</p>
                        <p>            self.name = name</p>
                        <p>        else:</p>
                        <p>            self.name = Person.default_name</p>
                        <p> </p>
                        <p> </p>
                        <p>tom = Person("Tom")</p>
                        <p>bob = Person("")</p>
                        <p>print(tom.name)  # Tom</p>
                        <p>print(bob.name)  # Undefined</p>
                    </code></pre>
                    <p>В данном случае атрибут default_name хранит имя по умолчанию. И если в конструктор передана пустая строка для имени, то атрибуту name передается значение атрибута класса default_name. Для обращения к атрибуту класса внутри методов можно применять имя класса</p>
                    <pre><code class="codeBlock">
                        <p>self.name = Person.default_name</p>
                    </code></pre>
                    <p>Атрибут класса</p>
                    <p>Возможна ситуация, когда атрибут класса и атрибут объекта совпадает по имени. Если в коде для атрибута объекта не задано значение, то для него может применяться значение атрибута класса:</p>
                    <pre><code class="codeBlock">
                        <p>class Person:</p>
                        <p>    name = "Undefined"</p>
                        <p> </p>
                        <p>    def print_name(self):</p>
                        <p>        print(self.name)</p>
                        <p> </p>
                        <p> </p>
                        <p>tom = Person()</p>
                        <p>bob = Person()</p>
                        <p>tom.print_name()    # Undefined</p>
                        <p>bob.print_name()    # Undefined</p>
                        <p> </p>
                        <p>bob.name = "Bob"</p>
                        <p>bob.print_name()    # Bob</p>
                        <p>tom.print_name()    # Undefined</p>
                    </code></pre>
                    <p>Здесь метод print_name использует атрибут объект name, однако нигде в коде этот атрибут не устанавливается. Зато на уровне класса задан атрибут name. Поэтому при первом обращении к методу print_name, в нем будет использоваться значение атрибута класса:</p>
                    <pre><code class="codeBlock">
                        <p>tom = Person()</p>
                        <p>bob = Person()</p>
                        <p>tom.print_name()    # Undefined</p>
                        <p>bob.print_name()    # Undefined</p>
                    </code></pre>
                    <p>Однако далее мы можем поменять установить атрибут объекта:</p>
                    <pre><code class="codeBlock">
                        <p>bob.name = "Bob"</p>
                        <p>bob.print_name()    # Bob</p>
                        <p>tom.print_name()    # Undefined</p>
                    </code></pre>
                    <p>Причем второй объект - tom продолжит использовать атрибут класса. И если мы изменим атрибут класса, соответственно значение tom.name тоже изменится:</p>
                    <pre><code class="codeBlock">
                        <p>tom = Person()</p>
                        <p>bob = Person()</p>
                        <p>tom.print_name()    # Undefined</p>
                        <p>bob.print_name()    # Undefined</p>
                        <p> </p>
                        <p>Person.name = "Some Person"     # меняем значение атрибута класса</p>
                        <p>bob.name = "Bob"                # устанавливаем атрибут объекта</p>
                        <p>bob.print_name()    # Bob</p>
                        <p>tom.print_name()    # Some Person</p>
                    </code></pre>
                    <p>Статические методы</p>
                    <p>Кроме обычных методов класс может определять статические методы. Такие методы предваряются аннотацией @staticmethod и относятся в целом к классу. Статические методы обычно определяют поведение, которое не зависит от конкретного объекта:</p>
                    <pre><code class="codeBlock">
                        <p>class Person:</p>
                        <p>    __type = "Person"</p>
                        <p> </p>
                        <p>    @staticmethod</p>
                        <p>    def print_type():</p>
                        <p>        print(Person.__type)</p>
                        <p> </p>
                        <p> </p>
                        <p>Person.print_type()     # Person - обращение к статическому методу через имя класса</p>
                        <p> </p>
                        <p>tom = Person()</p>
                        <p>tom.print_type()     # Person - обращение к статическому методу через имя объекта</p>
                    </code></pre>
                    <p>В данном случае в классе Person определен атрибут класса __type, который хранит значение, общее для всего класса - название класса. Причем поскольку название атрибута предваряется двумя подчеркиваниями, то данный атрибут будет приватным, что защитит от недопустимого изменения.</p>
                    <p>Также в классе Person определен статический метод print_type, который выводит на консоль значение атрибута __type. Действие этого метода не зависит от конкретного объекта и относится в целом ко всему классу - вне зависимости от объекта на консоль будет выводится одно и то же значение атрибута __type. Поэтому такой метод можно сделать статическим.</p>
                    <p><!--  --></p>
                    <p>Начиная с 3-й версии в языке программирования Python все классы неявно имеют один общий суперкласс - object и все классы по умолчанию наследуют его методы.</p>
                    <p>Одним из наиболее используемых методов класса object является метод __str__(). Когда необходимо получить строковое представление объекта или вывести объект в виде строки, то Python как раз вызывает этот метод. И при определении класса хорошей практикой считается переопределение этого метода.</p>
                </div>
                <div id="them6">
                    <h4>Класс object. Строковое представление объекта</h4>
                    <p>К примеру, возьмем класс Person и выведем его строковое представление:</p>
                    <pre><code class="codeBlock">
                        <p>class Person:</p>
                        <p>    def __init__(self, name, age):</p>
                        <p>        self.name = name  # устанавливаем имя</p>
                        <p>        self.age = age  # устанавливаем возраст</p>
                        <p> </p>
                        <p>    def display_info(self):</p>
                        <p>        print(f"Name: {self.name}  Age: {self.age}")</p>
                        <p> </p>
                        <p> </p>
                        <p>tom = Person("Tom", 23)</p>
                        <p>print(tom)</p>
                    </code></pre>
                    <p>При запуске программа выведет что-то наподобие следующего:</p>
                    <pre><code class="codeBlock">
                        <p><__main__.Person object at 0x10a63dc00></p>
                    </code></pre>
                    <p>Это не очень информативная информация об объекте. Мы, конечно, можем выйти из положения, определив в классе Person дополнительный метод, который выводит данные объекта - в примере выше это метод display_info.</p>
                    <p>Но есть и другой выход - определим в классе Person метод __str__() (по два подчеркивания с каждой стороны):</p>
                    <pre><code class="codeBlock">
                        <p>class Person:</p>
                        <p>    def __init__(self, name, age):</p>
                        <p>        self.name = name  # устанавливаем имя</p>
                        <p>        self.age = age  # устанавливаем возраст</p>
                        <p> </p>
                        <p>    def display_info(self):</p>
                        <p>        print(self)</p>
                        <p>        # print(self.__str__())     # или так</p>
                        <p> </p>
                        <p>    def __str__(self):</p>
                        <p>        return f"Name: {self.name}  Age: {self.age}"</p>
                        <p> </p>
                        <p> </p>
                        <p>tom = Person("Tom", 23)</p>
                        <p>print(tom)      # Name: Tom  Age: 23</p>
                        <p>tom.display_info()  # Name: Tom  Age: 23</p>
                        <p>Метод __str__ должен возвращать строку. И в данном случае мы возвращаем базовую информацию о человеке. Если нам потребуется использовать эту информацию в других методах класса, то мы можем использовать выражение self.__str__()</p>
                        <p>И теперь консольный вывод будет другим:</p>
                        <p>Name: Tom  Age: 23</p>
                        <p>Name: Tom  Age: 23</p>
                    </code></pre>
                </div>
                <div id="them7">
                    <h4>Перегрузка операторов</h4>
                    <p>Чтобы определить оператор для некоторого класса, данный класс должен реализовать соответствующую функцию. Так, для определения оператора сложения применяется функция __add__(), поэтому внутри класса нам надо определить данную функцию. Например:</p>
                    <pre><code class="codeBlock">
                        <p>class Counter:</p>
                        <p>    def __init__(self, value):</p>
                        <p>        self.value = value</p>
                        <p>    # переопределение оператора сложения</p>
                        <p>    def __add__(self, other):</p>
                        <p>        return Counter(self.value + other.value)</p>
                        <p>     </p>
                        <p>counter1 = Counter(5)</p>
                        <p>counter2 = Counter(15)</p>
                        <p>counter3 = counter1 + counter2</p>
                        <p>print(counter3.value)       # 20</p>
                    </code></pre>
                    <p>Здесь определен класс Counter, который имеет атрибут value - условное некоторое число. С помощью функции __add__ определяем для типа Counter оператор сложения. Допустим, мы хотим, чтобы один объект Counter можно было сложить с другим объектом Counter. В этом случае второй параметр функции будет представлять другой объект Counter:</p>
                    <pre><code class="codeBlock">
                        <p>def __add__(self, other):</p>
                        <p>    return Counter(self.value + other.value)</p>
                    </code></pre>
                    <p>В результате возвращаем новый объект Counter, в который помещается сумма атрибутов value обоих объектов.</p>
                    <p>После этого мы сможем складывать два объекта Counter, и результатом сложения будет новый объект Counter.</p>
                    <p>Причем в данном случае реализован не единственно возможный вариант оператора сложения. Так, в примере выше второй параметр функции представлял другой объект Counter. Но в реалньости это может быть любой тип. Например, что, если мы хотим складывать Counter не с другим объектом Counter, а с числом. Тогда мы могли определить следующий оператор:</p>
                    <pre><code class="codeBlock">
                        <p>class Counter:</p>
                        <p>    def __init__(self, value):</p>
                        <p>        self.value = value</p>
                        <p>         </p>
                        <p>    def __add__(self, other):</p>
                        <p>        return Counter(self.value + other)</p>
                        <p>     </p>
                        <p>counter1 = Counter(5)</p>
                        <p>counter3 = counter1 + 6</p>
                        <p>print(counter3.value)       # 11</p>
                    </code></pre>
                    <p>Здесь оператор сложения по прежнему возвращает объект Counter, только теперь второй параметр представляет обычное число.</p>
                    <p>Возвращаемый тип ряда операторов также жестко не определен. Например, мы могли бы возвращить также обычное число:</p>
                    <pre><code class="codeBlock">
                        <p>class Counter:</p>
                        <p>    def __init__(self, value):</p>
                        <p>        self.value = value</p>
                        <p>         </p>
                        <p>    def __add__(self, other):</p>
                        <p>        return self.value + other</p>
                        <p>     </p>
                        <p>counter1 = Counter(5)</p>
                        <p>result = counter1 + 7</p>
                        <p>print(result)       # 12</p>
                    </code></pre>
                    <p>Рассмотрим еще ряд примеров определения операторов.</p>
                    <p>Истинность объекта</p>
                    <p>Определение функции __bool__ позволяет установить истинность объекта или фактически преобразовать объект к значениям True/False. Например:</p>
                    <pre><code class="codeBlock">
                        <p>class Counter:</p>
                        <p>    def __init__(self, value):</p>
                        <p>        self.value = value</p>
                        <p>    def __bool__(self):</p>
                        <p>        return self.value > 0</p>
                        <p>     </p>
                        <p>def test(counter):</p>
                        <p>    if counter: print("Counter = True")</p>
                        <p>    else: print("Counter = False")</p>
                        <p>     </p>
                        <p>counter1 = Counter(3)</p>
                        <p>test(counter1)              # Counter = True</p>
                        <p> </p>
                        <p>counter2 = Counter(-3)</p>
                        <p>test(counter2)              # Counter = False</p>
                    </code></pre>
                    <p>В данном случае будем считать, что, если значение value в Counter меньше 1, то объект Counter будет рассматриваться как False, а при положительных значениях - как True. Благодаря этому мы можем использовать объект Counter в условных или циклических конструкциях. Так, в примере выше для тестирования определена функция test, которая в конструкции if..else проверяет значение объекта Counter и в зависимости от результата проверки выводит определенное сообщение на консоль.</p>
                    <p>Или, например, мы могли бы использовать объект Counter в цикле while в качестве условия:</p>
                    <pre><code class="codeBlock">
                        <p>class Counter:</p>
                        <p>    def __init__(self, value):</p>
                        <p>        self.value = value</p>
                        <p>    def __bool__(self):</p>
                        <p>        return self.value > 0</p>
                        <p>     </p>
                        <p>counter1 = Counter(3)</p>
                        <p> </p>
                        <p>while(counter1):</p>
                        <p>    print("Counter1: ", counter1.value)</p>
                        <p>    counter1.value -=1</p>
                    </code></pre>
                    <p>В данном случае цикл while будет выполняться, пока counter1 соответствует значению True (по сути покак его значение value больше 0)</p>
                    <p>Операторы, которые возвращают значение bool</p>
                    <p>Ряд операций призваны возвращать логическое значение True или False. Например, операции сравнения:</p>
                    <pre><code class="codeBlock">
                        <p>class Counter:</p>
                        <p>    def __init__(self, value):</p>
                        <p>        self.value = value</p>
                        <p>         </p>
                        <p>    def __gt__(self, other):</p>
                        <p>        return self.value > other.value</p>
                        <p>    def __lt__(self, other):</p>
                        <p>        return self.value < other.value</p>
                        <p> </p>
                        <p>     </p>
                        <p>counter1 = Counter(1)</p>
                        <p>counter2 = Counter(2)</p>
                        <p>     </p>
                        <p>if counter1 > counter2: </p>
                        <p>    print("counter1 больше чем counter2")</p>
                        <p>elif counter1 < counter2:</p>
                        <p>    print("counter1 меньше чем counter2")</p>
                        <p>else: </p>
                        <p>    print("counter1 и counter2 равны")</p>
                    </code></pre>
                    <p>Здесь в классе Counter определены операторы < (функция __lt__()) и > (функция __gt__()). В данном случае сравниваем с другим объектом Counter. В реальности же сравниваем значения атрибутов двух объектов.</p>
                    <pre><code class="codeBlock">
                        <p>def __gt__(self, other):</p>
                        <p>    return self.value > other.value</p>
                        <p>def __lt__(self, other):</p>
                        <p>    return self.value < other.value</p>
                        <p>Затем мы можем применять соответствующие операции к двум объектам Counter:</p>
                        <p>1</p>
                        <p>if counter1 > counter2:</p>
                    </code></pre>
                    <p>Операции обращения по индексу</p>
                    <p>Ряд операторов позволяют обращаться к объекту по индексу, используя квадратные скобки:</p>
                    <p>obj[index]</p>
                    <p>Обычно подобные операции применяются по отношению к коллекциям, которые будут рассмотрены в последующих статьях. Например, можно использовать подобные операции для получения или изменения какого-то элемента списка значений. В реальности эти операции могут применяться к любому объекту, а используемый индекс также может представлять все что угодно. Рассмотрим операции обращения по индексу на примере получения значения по индексу:</p>
                    <pre><code class="codeBlock">
                        <p>class Person:</p>
                        <p>    def __init__(self, name, age):</p>
                        <p>        self.__name = name</p>
                        <p>        self.__age = age</p>
                        <p>         </p>
                        <p>    def __getitem__(self, prop):</p>
                        <p>        if prop == "name": return self.__name</p>
                        <p>        elif prop == "age": return self.__age</p>
                        <p>        return None</p>
                        <p>     </p>
                        <p>tom = Person("Tom", 39)</p>
                        <p> </p>
                        <p>print("Name:", tom["name"])     # Name: Tom</p>
                        <p>print("Age:", tom["age"])       # Age: 39</p>
                        <p>print("Id:", tom["id"])         # Id: None</p>
                    </code></pre>
                    <p>Итак, здесь определен класс Person, содержит два приватных поля - __name и __age. Для реализации получения данных по индексу определена функция __getitem__(). В качестве второго параметра эту функцию передается значение, которое выполняет роль индекса. В нашем случае это будет название атрибута. И в зависимости от переданного значения возвращаем либо значение атрибута __name, либо значение атрибута __age. Если передано невалидное названия атрибута, то возвращаем None.</p>
                    <p>Для получения значения по индесу передаем индекс - название атрибута в квадратных скобках:</p>
                    <p>tom["name"]</p>
                    <p>Проверка наличия свойства</p>
                    <p>Оператор in позволяет проверить наличие определенного значения в последовательности - некотором наборе значений:</p>
                    <p>значение in последовательность</p>
                    <p>Если значение присутствует в последовательности, то возвращается True, иначе возвращается False. Например, проверим наличие свойства в объекте:</p>
                    <pre><code class="codeBlock">
                        <p>class Person:</p>
                        <p>    def __init__(self, name, age):</p>
                        <p>        self.name = name</p>
                        <p>        self.age = age</p>
                        <p>         </p>
                        <p>    def __contains__(self, prop):</p>
                        <p>        if prop == "name" or prop == "age": return True</p>
                        <p>        return False</p>
                        <p>     </p>
                        <p>tom = Person("Tom", 39)</p>
                        <p>print("name" in tom)        # True</p>
                        <p>print("id" in tom)          # False</p>
                    </code></pre>
                    <p>За реализацию оператора in отвечает функция __contains__(). В качестве первого параметра, как обычно, указывается текущий объект - тот объект, который стоит справа от оператора in. А в качестве второго параметра - проверяемое значение - оно указывается слева от in. В данном случае если второй параметр - равен "name" или "age", то возвращаем True. Что означает, что атрибут есть в объекте.</p>
                    <p>Соответственно выражение "name" in tom возвратит True, а выражение "id" in tom возвратит False.</p>
                    <p>Реализация операторов парами</p>
                    <p>Некоторые операторы - операторы сравения удобнее реализовать парами. Если мы реализуем оператор ==, то можно сразу реализовать и оператор !=. Причем чтобы не прописывать одну и ту же логику по два раза, можно реализовать один оператор через другой:</p>
                    <pre><code class="codeBlock">
                        <p>class Counter:</p>
                        <p>    def __init__(self, value):</p>
                        <p>        self.value = value</p>
                        <p>     </p>
                        <p>    def __eq__(self, other): return self.value == other.value</p>
                        <p>    def __ne__(self, other): return not (self == other)</p>
                        <p>     </p>
                        <p>    def __gt__(self, other): return self.value > other.value</p>
                        <p>    def __le__(self, other): return not (self > other)</p>
                        <p>     </p>
                        <p>    def __lt__(self, other): return self.value < other.value</p>
                        <p>    def __ge__(self, other): return not (self < other)</p>
                        <p>         </p>
                        <p>c1 = Counter(1)</p>
                        <p>c2 = Counter(2)</p>
                        <p> </p>
                        <p>print(c1 == c2)     # False</p>
                        <p>print(c1 != c2)     # True</p>
                        <p> </p>
                        <p>print(c1 < c2)      # True</p>
                        <p>print(c1 >= c2)     # False</p>
                        <p>В данном случае оператора != возвращает инверсию результата оператора ==, который определен выше</p>
                        <p>1</p>
                        <p>2</p>
                        <p>def __eq__(self, other): return self.value == other.value</p>
                        <p>def __ne__(self, other): return not (self == other)</p>
                    </code></pre>
                    <p>Аналогично определены операторы < и >=, а также > и <=.</p>
                </div>
                <div id="them8">
                    <h4>Абстрактные классы и методы</h4>
                    <p>Обычно классы отражают некоторые объекты окружающей действительности. Но иногда нам приходится работать с сущностями, которые не имеют конкретного воплощения. Например, сущность "животное". Есть конкретные животные - кошка, собака и так далее, но животное как таковое не имеет конкретного воплощения. Или сущность "геометрическая фигура". Есть прямоугольник, квадрат, круг, треугольник, но сама по себе геометрическая фигура также не имеет конкретного воплощения. И обычно для описания подобных сущностей применяются абстрактные классы.</p>
                    <p>В языке Python все инструменты для создания абстрактных классов определены в специальном модуле abc, который надо дополнительно подключать в приложении</p>
                    <p>import abc</p>
                    <p>Ключевыми компонентами этого модуля является класс ABC и аннотация @abstractmethod. Класс ABC упрощает создание абстрактного класса, и все определяемые абстрактные классы наследуются от этого класса. Аннотация @abstractmethod предназначеня для создания абстрактного метода.</p>
                    <p>Абстрактные классы определяются как обычные классы за тем исключением, что они наследуются от класса ABC из модуля abc. Например, определим абстрактный класс геометрической фигуры:</p>
                    <pre><code class="codeBlock">
                        <p>import abc</p>
                        <p>class Shape(abc.ABC):</p>
                        <p>    pass</p>
                    </code></pre>
                    <p>Как правило, абстрактные классы объявляют некоторый общий функционал для классов наследников. Причем некоторый функционал может не иметь никакой реализации - его реализацию должны определить классы-наследники. Подобный функционал оформляется в классе в виде абстрактных методов. Например, класс геометрической фигуры может иметь методы вычисления периметра, площади и т.д. Мы не можем определить общую формулу для вычисления площади всех фигур - для каждой конкретной фигуры принцип вычисления площади может отличаться. Поэтому в классе фигуры мы можем определить метод вычисления площади как абстрактный. Для этого применяется аннотация @abstractmethod из модуля abc:</p>
                    <pre><code class="codeBlock">
                        <p>import abc</p>
                        <p>class Shape(abc.ABC):</p>
                        <p>    @abc.abstractmethod </p>
                        <p>    def area (self): pass       # площадь фигуры</p>
                    </code></pre>
                    <p>В данном случае метод area() определен как абстрактный. Так как ему не нужен конкретный функционал, в нем вызывается оператор pass</p>
                    <p>Стоит отметить, что мы не можем напрямую создать объект абстрактного класса с абстрактными методами, используя его конструктор:</p>
                    <pre><code class="codeBlock">
                        <p>import abc</p>
                        <p>class Shape(abc.ABC):</p>
                        <p>    @abc.abstractmethod </p>
                        <p>    def area (self): pass       # площадь фигуры</p>
                        <p> </p>
                        <p>shape = Shape()     # ! Ошибка - так нельзя</p>
                        <p>print(shape)</p>
                    </code></pre>
                    <p>Классы-наследники должны реализовать все абстрактные методы абстрактного класса. Например, определим класс прямоугольника:</p>
                    <pre><code class="codeBlock">
                        <p>import abc</p>
                        <p>class Shape(abc.ABC):</p>
                        <p>    @abc.abstractmethod </p>
                        <p>    def area (self): pass       # площадь фигуры</p>
                        <p> </p>
                        <p># класс прямоугольника </p>
                        <p>class Rectangle(Shape):</p>
                        <p>    def __init__(self, width, height):</p>
                        <p>        self.width = width</p>
                        <p>        self.height = height</p>
                        <p>    def area (self): return self.width * self.height</p>
                        <p>     </p>
                        <p>rect = Rectangle(30, 50)</p>
                        <p>print("Rectangle area:", rect.area())   # Rectangle area: 1500 </p>
                    </code></pre>
                    <p>Здесь класс прямоугольника Rectangle принимает через конструктор ширину и высоту и использует их для вычисления площади в методе area().</p>
                    <p>Подобным образом можно определить и другие типы фигур. Например, добавим класс круга:</p>
                    <pre><code class="codeBlock">
                        <p>import abc</p>
                        <p>class Shape(abc.ABC):</p>
                        <p>    @abc.abstractmethod </p>
                        <p>    def area (self): pass       # площадь фигуры</p>
                        <p> </p>
                        <p># класс прямоугольника </p>
                        <p>class Rectangle(Shape):</p>
                        <p>    def __init__(self, width, height):</p>
                        <p>        self.width = width</p>
                        <p>        self.height = height</p>
                        <p>    def area (self): return self.width * self.height</p>
                        <p>     </p>
                        <p># класс круга </p>
                        <p>class Circle(Shape):</p>
                        <p>    def __init__(self, radius):</p>
                        <p>        self.radius = radius</p>
                        <p>    def area (self): return self.radius * self.radius * 3.14</p>
                        <p>     </p>
                        <p> </p>
                        <p>def print_area(shape):</p>
                        <p>    print("Area:", shape.area())</p>
                        <p>     </p>
                        <p> </p>
                        <p>rect = Rectangle(30, 50)</p>
                        <p>circle = Circle(30)</p>
                        <p>print_area(rect)        # Area: 1500</p>
                        <p>print_area(circle)      # Area: 2826.0</p>
                    </code></pre>
                    <p>В данном случае для вывода площади фигуры определена функция print_area, которая принимает любую фигуру.</p>
                    <p>При этом абстрактные классы также могут определять конструктор, атрибуты, неабстрактные методы, которые также могут применяться в классах-наследниках:</p>
                    <pre><code class="codeBlock">
                        <p>import abc</p>
                        <p>class Shape(abc.ABC):</p>
                        <p>    def __init__(self, x, y):</p>
                        <p>        self.x = x</p>
                        <p>        self.y = y </p>
                        <p>         </p>
                        <p>    @abc.abstractmethod     </p>
                        <p>    def area (self): pass       # абстрактны метод</p>
                        <p>     </p>
                        <p>    def print_point(self):          # неабстрактный метод</p>
                        <p>        print("X:", self.x, "\tY:", self.y)</p>
                        <p> </p>
                        <p># класс прямоугольника </p>
                        <p>class Rectangle(Shape):</p>
                        <p>    def __init__(self, x, y, width, height):</p>
                        <p>        super().__init__(x, y)</p>
                        <p>        self.width = width</p>
                        <p>        self.height = height</p>
                        <p>    def area (self): return self.width * self.height</p>
                        <p>     </p>
                        <p> </p>
                        <p>rect = Rectangle(10, 20, 100, 100)</p>
                        <p>rect.print_point()      # X: 10   Y: 20</p>
                    </code></pre>
                    <p>Здесь абстрактный класс Shape через конструктор принимает координаты X и Y для точки, относительно которой создается фигура (например, для прямоугольника это могут быть координаты верхнего левого угла, для круга - центр). И также определен неабстрактный метод print_point, который выводит координаты точки на консоль.</p>
                </div>
            </div>
        </div>
    </div>
    <footer class="bg-dark text-white pt-5 pb-4">
        <div class="container">
            <div class="row">
                <div class="col-md-4 mb-4 mb-md-0">
                    <h5>О компании</h5>
                    <p>Краткое описание вашей компании и ее деятельности.</p>
                </div>

                <div class="col-md-4 mb-4 mb-md-0">
                    <h5>Контакты</h5>
                    <ul class="list-unstyled">
                        <li><i class="bi bi-geo-alt"></i> Адрес: г. Город, ул. Улица, д. 1</li>
                        <li><i class="bi bi-phone"></i> Телефон: +7 (123) 456-78-90</li>
                        <li><i class="bi bi-envelope"></i> Email: info@example.com</li>
                    </ul>
                </div>

                <div class="col-md-4">
                    <h5>Социальные сети</h5>
                    <div class="d-flex gap-3">
                        <a href="#" class="text-dark"><i class="bi bi-facebook fs-4"></i></a>
                        <a href="#" class="text-dark"><i class="bi bi-twitter fs-4"></i></a>
                        <a href="#" class="text-dark"><i class="bi bi-instagram fs-4"></i></a>
                    </div>
                </div>
            </div>

            <hr class="my-4">

            <div class="row">
                <div class="col-md-6 text-center text-md-start">
                    <p class="mb-0">© 2023 Ваша компания. Все права защищены.</p>
                </div>
                <div class="col-md-6 text-center text-md-end">
                    <ul class="list-inline mb-0">
                        <li class="list-inline-item"><a href="#">Политика конфиденциальности</a></li>
                        <li class="list-inline-item"><a href="#">Условия использования</a></li>
                    </ul>
                </div>
            </div>
        </div>
    </footer>
    <script src="../../js/bootstrap.bundle.min.js"></script>
</body>

</html>
