<p><!--  --></p>
<p><!--  --></p>
<p><!--  --></p>
<p><!--  --></p>
<p>Python поддерживает все распространенные арифметические операции:</p>
<p>+</p>
<p>Сложение двух чисел:</p>
<p>1</p>
<p>print(6 + 2)  # 8</p>
<p>-</p>
<p>Вычитание двух чисел:</p>
<p>1</p>
<p>print(6 - 2)  # 4</p>
<p>*</p>
<p>Умножение двух чисел:</p>
<p>1</p>
<p>print(6 * 2)  # 12</p>
<p>/</p>
<p>Деление двух чисел:</p>
<p>1</p>
<p>print(6 / 2)  # 3.0</p>
<p>//</p>
<p>Целочисленное деление двух чисел:</p>
<p>1</p>
<p>2</p>
<p>print(7 / 2)  # 3.5</p>
<p>print(7 // 2)  # 3</p>
<p>Данная операция возвращает целочисленный результат деления, отбрасывая дробную часть</p>
<p>**</p>
<p>Возведение в степень:</p>
<p>1</p>
<p>print(6 ** 2)  # Возводим число 6 в степень 2. Результат - 36</p>
<p>%</p>
<p>Получение остатка от деления:</p>
<p>1</p>
<p>print(7 % 2)  # Получение остатка от деления числа 7 на 2. Результат - 1</p>
<p>В данном случае ближайшее число к 7, которое делится на 2 без остатка, это 6. Поэтому остаток от деления равен 7 - 6 = 1</p>
<p>При последовательном использовании нескольких арифметических операций их выполнение производится в соответствии с их приоритетом. В начале выполняются операции с большим приоритетом. Приоритеты операций в порядке убывания приведены в следующей таблице.</p>
<p>Операции</p>
<p>Направление</p>
<p>**</p>
<p>Справо налево</p>
<p>* / // %</p>
<p>Слева направо</p>
<p>+ -</p>
<p>Слева направо</p>
<p>Пусть у нас выполняется следующее выражение:</p>
<p>1</p>
<p>2</p>
<p>number = 3 + 4 * 5 ** 2 + 7</p>
<p>print(number)  # 110</p>
<p>Здесь начале выполняется возведение в степень (5 ** 2) как операция с большим приоритетом, далее результат умножается на 4 (25 * 4), затем происходит сложение (3 + 100) и далее опять идет сложение (103 + 7).</p>
<p>Чтобы переопределить порядок операций, можно использовать скобки:</p>
<p>1</p>
<p>2</p>
<p>number = (3 + 4) * (5 ** 2 + 7)</p>
<p>print(number)  # 224</p>
<p>Следует отметить, что в арифметических операциях могут принимать участие как целые, так и дробные числа. Если в одной операции участвует целое число (int) и число с плавающей точкой (float), то целое число приводится к типу float.</p>
<p>tornadoenergy.me</p>
<p>Реклама</p>
<p>Арифметические операции с присвоением</p>
<p>Ряд специальных операций позволяют использовать присвоить результат операции первому операнду:</p>
<p>+=</p>
<p>Присвоение результата сложения</p>
<p>-=</p>
<p>Присвоение результата вычитания</p>
<p>*=</p>
<p>Присвоение результата умножения</p>
<p>/=</p>
<p>Присвоение результата от деления</p>
<p>//=</p>
<p>Присвоение результата целочисленного деления</p>
<p>**=</p>
<p>Присвоение степени числа</p>
<p>%=</p>
<p>Присвоение остатка от деления</p>
<p>Примеры операций:</p>
<p>1</p>
<p>2</p>
<p>3</p>
<p>4</p>
<p>5</p>
<p>6</p>
<p>7</p>
<p>8</p>
<p>9</p>
<p>number = 10</p>
<p>number += 5</p>
<p>print(number)  # 15</p>
<p> </p>
<p>number -= 3</p>
<p>print(number)  # 12</p>
<p> </p>
<p>number *= 4</p>
<p>print(number)  # 48</p>
<p>Округление и функция round</p>
<p>При операциях с числами типа float надо учитывать, что результат операций с ними может быть не совсем точным. Например:</p>
<p>1</p>
<p>2</p>
<p>3</p>
<p>4</p>
<p>first_number = 2.0001</p>
<p>second_number = 5</p>
<p>third_number = first_number / second_number</p>
<p>print(third_number) # 0.40002000000000004</p>
<p>В данном случае мы ожидаем получить число 0.40002, однако в конце через ряд нулей появляется еще какая-то четверка. Или еще одно выражение:</p>
<p>1</p>
<p>print(2.0001 + 0.1)  # 2.1001000000000003</p>
<p>В случае выше для округления результата мы можем использовать встроенную функцию round():</p>
<p>1</p>
<p>2</p>
<p>3</p>
<p>4</p>
<p>first_number = 2.0001</p>
<p>second_number = 0.1</p>
<p>third_number = first_number + second_number</p>
<p>print(round(third_number))  # 2</p>
<p>В функцию round() передается число, которое надо округлить. Если в функцию передается одно число, как в примере выше, то оно округляется до целого.</p>
<p>Функция round() также может принимать второе число, которое указывает, сколько знаков после запятой должно содержать получаемое число:</p>
<p>1</p>
<p>2</p>
<p>3</p>
<p>4</p>
<p>first_number = 2.0001</p>
<p>second_number = 0.1</p>
<p>third_number = first_number + second_number</p>
<p>print(round(third_number, 4))  # 2.1001</p>
<p>В данном случае число third_number округляется до 4 знаков после запятой.</p>
<p>Если в функцию передается только одно значение - только округляемое число, оно округляется то ближайшего целого</p>
<p>Примеры округлений:</p>
<p>1</p>
<p>2</p>
<p>3</p>
<p># округление до целого числа</p>
<p>print(round(2.49))  # 2 - округление до ближайшего целого 2</p>
<p>print(round(2.51))  # 3</p>
<p>Однако если округляемая часть равна одинаково удалена от двух целых чисел, то округление идет к ближайшему четному:</p>
<p>1</p>
<p>2</p>
<p>print(round(2.5))   # 2 - ближайшее четное</p>
<p>print(round(3.5))   # 4 - ближайшее четное</p>
<p>Округление производится до ближайшего кратного 10 в степени минус округляемая часть:</p>
<p>1</p>
<p>2</p>
<p>3</p>
<p>4</p>
<p>5</p>
<p># округление до двух знаков после запятой</p>
<p>print(round(2.554, 2))      # 2.55</p>
<p>print(round(2.5551, 2))      # 2.56</p>
<p>print(round(2.554999, 2))   # 2.55</p>
<p>print(round(2.499, 2))      # 2.5</p>
<p>Однако следует учитывать, что функция round() не идеальный инструмент. Например, выше при округление до целых чисел применяется правило, согласно которому, если округляемая часть одинаково удалена от двух значений, то округление производится до ближайшего четного значения. В Python в связи с тем, что десятичная часть числа не может быть точно представлена в виде числа float, то это может приводить к некоторым не совсем ожидаемым результатам. Например:</p>
<p>1</p>
<p>2</p>
<p>3</p>
<p>4</p>
<p>5</p>
<p>6</p>
<p>7</p>
<p>8</p>
<p>9</p>
<p># округление до двух знаков после запятой</p>
<p>print(round(2.545, 2))   # 2.54</p>
<p>print(round(2.555, 2))   # 2.56 - округление до четного</p>
<p>print(round(2.565, 2))   # 2.56</p>
<p>print(round(2.575, 2))   # 2.58</p>
<p> </p>
<p>print(round(2.655, 2))   # 2.65 - округление не до четного</p>
<p>print(round(2.665, 2))   # 2.67</p>
<p>print(round(2.675, 2))   # 2.67</p>
<p>Подобно о проблеме можно почитать к документации.</p>
<p><!--  --></p>
<p><!--  --></p>